

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>p_input &mdash; call-time-model  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/p_theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> call-time-model
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../config_files.html">Config Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">call-time-model</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>p_input</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for p_input</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Functions generating input for brian2 model neurons: spike times for SpikeGenerator and step and ramp currents.</span>
<span class="sd">(generate_current partly reuses code from http://neuronaldynamics.epfl.ch) [call-time-model]</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">brian2</span> <span class="k">as</span> <span class="nn">b2</span>
<span class="kn">from</span> <span class="nn">fcn</span> <span class="kn">import</span> <span class="n">p_io</span><span class="p">,</span> <span class="n">p_util</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>


<div class="viewcode-block" id="get_offset_noise"><a class="viewcode-back" href="../p_input.html#p_input.get_offset_noise">[docs]</a><span class="k">def</span> <span class="nf">get_offset_noise</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get as many random numbers sampled from the standard normal distribution (using brian2.randn()) as needed for</span>
<span class="sd">    noise offsets during current generation.</span>

<span class="sd">    :param config: dictionary of model parameters, as loaded from .json configuration file</span>
<span class="sd">    :type config: dict</span>
<span class="sd">    :return: offset_noise: list of numpy arrays of random numbers for current generation, one array per population</span>
<span class="sd">    :rtype: offset_noise: [numpy.ndarray] or [[], [], ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;p_input.get_random_offsets(): arg config must be dictionary (as loaded from .json)&quot;</span>

    <span class="n">n_populations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;population_id&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;offset_range&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span> \
            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;offset_range&#39;</span><span class="p">]):</span>
        <span class="c1"># generated the random numbers needed for each population</span>
        <span class="n">offset_noise</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
            <span class="c1"># get number of currents for this population. if t_start is a free parameter, this is contained in a sublist</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">n_currents</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_currents</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">pop</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;offset_range&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_rand_offsets</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_currents</span>
                <span class="n">offset_noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_rand_offsets</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset_noise</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="k">return</span> <span class="n">offset_noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="n">n_populations</span></div>


<div class="viewcode-block" id="get_white_noise"><a class="viewcode-back" href="../p_input.html#p_input.get_white_noise">[docs]</a><span class="k">def</span> <span class="nf">get_white_noise</span><span class="p">(</span><span class="n">config</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get as many random numbers sampled from the standard normal distribution (using brian2.randn()) as needed for</span>
<span class="sd">    white noise during current generation (within step/ramp random sample-to-sample variability)</span>

<span class="sd">    :param config: dictionary of model parameters, as loaded from .json configuration file</span>
<span class="sd">    :type config: dict</span>
<span class="sd">    :return: white_noise: list list(s) of numpy arrays of random numbers for current generation. one sublist per</span>
<span class="sd">        population, one array per neuron. list of Nones if no numbers were generated (one None per population)</span>
<span class="sd">    :rtype: white_noise: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;p_input.get_random_offsets(): arg config must be dictionary (as loaded from .json)&quot;</span>

    <span class="n">n_populations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;population_id&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;wnoise_cv&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span> \
            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;wnoise_cv&#39;</span><span class="p">]):</span>
        <span class="c1"># generated the random numbers needed for each population</span>
        <span class="n">white_noise</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
            <span class="c1"># get number of samples needed</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;sim_time&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;wnoise_dt&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">white_noise</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;wnoise_cv&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">nrn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">]):</span>
                    <span class="c1"># get a large, fixed number of random floats (exceeding simulation time), so that used</span>
                    <span class="c1"># random numbers are consistent when changing simulation time, but keeping the same seed.</span>
                    <span class="n">tmp_lots_of_random_numbers</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span>
                    <span class="n">white_noise</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_lots_of_random_numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_samples</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">white_noise</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="k">return</span> <span class="n">white_noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_populations</span></div>


<div class="viewcode-block" id="setup_currents"><a class="viewcode-back" href="../p_input.html#p_input.setup_currents">[docs]</a><span class="k">def</span> <span class="nf">setup_currents</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">offset_noise</span><span class="p">,</span> <span class="n">white_noise</span><span class="p">,</span> <span class="n">log_name</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b_gen_curr_per_pop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">I_input_prev</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate and return time series of currents to be used as input onto model neurons, based on specifications in</span>
<span class="sd">    config (e.g. loaded from .json config file).</span>

<span class="sd">    :param config: dictionary of model parameters as loaded from .json configuration file</span>
<span class="sd">    :type config: dict</span>
<span class="sd">    :param offset_noise: list of numpy arrays of random numbers used in randomly offsetting current amplitudes.</span>
<span class="sd">        one array per population. empty list instead of array where no numbers were generated (one [] per pop)</span>
<span class="sd">    :type offset_noise: list</span>
<span class="sd">    :param white_noise: list of list(s) of numpy arrays of random numbers used for additive noise in current generation.</span>
<span class="sd">        one sublist per population, one array per neuron. list of Nones if no numbers were generated (one None per pop)</span>
<span class="sd">    :type white_noise: list</span>
<span class="sd">    :param log_name: name of logger object (standard python logging) created earlier, e.g. through p_io.set_up_loggers()</span>
<span class="sd">    :type log_name: str</span>
<span class="sd">    :param sim_time_ms: [default=None] duration of simulation in milliseconds. if None: load from config file</span>
<span class="sd">    :type sim_time_ms: int or None</span>
<span class="sd">    :param b_gen_curr_per_pop: [default=None] list of one bool per population. if true, generate currents only for the</span>
<span class="sd">        respective population and overwrite I_input_prev for those. if None, generate currents for all populations.</span>
<span class="sd">    :type b_gen_curr_per_pop: list or None</span>
<span class="sd">    :param I_input_prev: [default=None] output of this function from the previous run. Supply if b_gen_curr_per_pop.</span>
<span class="sd">    :type I_input_prev: brian2.TimedArray or None</span>
<span class="sd">    :return:</span>
<span class="sd">        - I_input: brian2.TimedArray containing all generated currents. (May be used in ode as Ie)</span>
<span class="sd">        - log_message: string containing message to be printed/logged</span>
<span class="sd">    :rtype:</span>
<span class="sd">        - I_input: brian2.input.timedarray.TimedArray</span>
<span class="sd">        - log_message: string</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;p_input.setup_currents(): argument config must be dictionary (as loaded from .json)&quot;</span>
    <span class="k">assert</span> <span class="n">sim_time_ms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sim_time_ms</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sim_time_ms</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> \
        <span class="s2">&quot;argument &#39;sim_time_ms&#39; must be an integer &gt;= 0 or None&quot;</span>
    <span class="k">if</span> <span class="n">b_gen_curr_per_pop</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">I_input_prev</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">b_gen_curr_per_pop</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_gen_curr_per_pop</span><span class="p">)</span> <span class="ow">is</span> \
            <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;population_id&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">I_input_prev</span><span class="p">)</span> <span class="o">==</span> <span class="n">b2</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">timedarray</span><span class="o">.</span><span class="n">TimedArray</span><span class="p">,</span> \
            <span class="s2">&quot;if b_gen_curr_per_pop (list of len n_pops), also supply I_input_prev (b2.input.timedarray.TimedArray).&quot;</span>
    <span class="k">if</span> <span class="n">I_input_prev</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">b_gen_curr_per_pop</span><span class="p">,</span> <span class="s2">&quot;if I_input_prev is passed, b_gen_curr_per_pop must also be passed (see docstring)&quot;</span>

    <span class="c1"># misc parameters</span>
    <span class="n">population_id</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;population_id&#39;</span><span class="p">]</span>
    <span class="n">n_populations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population_id</span><span class="p">)</span>
    <span class="n">n_per_pop</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sim_time_ms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sim_time_ms</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;sim_time&#39;</span><span class="p">]</span>

    <span class="c1"># get logger object</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">log_name</span><span class="p">)</span>

    <span class="c1"># get unit for input current</span>
    <span class="k">if</span> <span class="s1">&#39;input_current&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="s1">&#39;input_current&#39;</span><span class="p">]):</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;b2.&#39;</span> <span class="o">+</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;&#39; for input_current&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;&#39; for input_current&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>

    <span class="c1"># generate input currents (Ie)</span>
    <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]:</span>
        <span class="n">timer_input_start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="c1"># check if all input_currents are applied within simulation time</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">values</span> <span class="o">&gt;</span> <span class="n">sim_time_ms</span> <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">t</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARNING: input currents extend beyond simulation time (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sim_time_ms</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ms)!&quot;</span><span class="p">)</span>
        <span class="n">input_current_t_start</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">]</span>
        <span class="n">input_current_amp_start</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;amp_start&#39;</span><span class="p">]</span>
        <span class="n">input_current_amp_end</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;amp_end&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;power_ramp&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]:</span>
            <span class="n">b_power_ramp_all</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;power_ramp&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b_power_ramp_all</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_populations</span>
        <span class="k">if</span> <span class="s1">&#39;offset_range&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]:</span>
            <span class="n">input_current_offset_range</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;offset_range&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_current_offset_range</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_populations</span>
        <span class="k">if</span> <span class="s1">&#39;wnoise_cv&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]:</span>
            <span class="n">input_current_wnoise_cv</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;wnoise_cv&#39;</span><span class="p">]</span>
            <span class="n">input_current_wnoise_dt</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;wnoise_dt&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_current_wnoise_cv</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="n">n_populations</span>
            <span class="n">input_current_wnoise_dt</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># generate input current for all populations (except for populations where b_gen_curr_per_pop is 0, if any)</span>
        <span class="n">input_currents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">b_gen_curr_per_pop</span> <span class="ow">or</span> <span class="p">(</span><span class="n">b_gen_curr_per_pop</span> <span class="ow">and</span> <span class="n">b_gen_curr_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">]):</span>
                <span class="n">input_currents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">generate_current</span><span class="p">(</span><span class="n">input_current_t_start</span><span class="p">[</span><span class="n">pop</span><span class="p">],</span> <span class="n">sim_time_ms</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
                                     <span class="p">[</span><span class="n">val</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">input_current_amp_start</span><span class="p">[</span><span class="n">pop</span><span class="p">]],</span>
                                     <span class="p">[</span><span class="n">val</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">input_current_amp_end</span><span class="p">[</span><span class="n">pop</span><span class="p">]],</span> <span class="n">n_neurons</span><span class="o">=</span><span class="n">n_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">],</span>
                                     <span class="n">offset_range</span><span class="o">=</span><span class="n">input_current_offset_range</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span>
                                     <span class="n">offset_noise</span><span class="o">=</span><span class="n">offset_noise</span><span class="p">[</span><span class="n">pop</span><span class="p">],</span>
                                     <span class="n">wnoise_cv</span><span class="o">=</span><span class="n">input_current_wnoise_cv</span><span class="p">[</span><span class="n">pop</span><span class="p">],</span> <span class="n">wnoise_dt</span><span class="o">=</span><span class="n">input_current_wnoise_dt</span><span class="p">,</span>
                                     <span class="n">white_noise</span><span class="o">=</span><span class="n">white_noise</span><span class="p">[</span><span class="n">pop</span><span class="p">],</span> <span class="n">b_power_ramp</span><span class="o">=</span><span class="n">b_power_ramp_all</span><span class="p">[</span><span class="n">pop</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># generate zero currents (will be overwritten in timedarray by I_input_prev.values below)</span>
                <span class="n">input_currents</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">]]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">I_input_prev</span><span class="p">:</span>
            <span class="n">max_len_curr_prev_run</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">I_input_prev</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">I_input_prev</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
            <span class="n">I_input</span> <span class="o">=</span> <span class="n">timedarray_from_current</span><span class="p">(</span><span class="n">input_currents</span><span class="p">,</span> <span class="n">unit_time</span><span class="o">=</span><span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;input_current&#39;</span><span class="p">,</span>
                                              <span class="n">pad_to_length</span><span class="o">=</span><span class="n">max_len_curr_prev_run</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">I_input</span> <span class="o">=</span> <span class="n">timedarray_from_current</span><span class="p">(</span><span class="n">input_currents</span><span class="p">,</span> <span class="n">unit_time</span><span class="o">=</span><span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;input_current&#39;</span><span class="p">)</span>
        <span class="c1"># if not all currents were re-generated, overwrite I_input from the previous run only with new values</span>
        <span class="k">if</span> <span class="n">b_gen_curr_per_pop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b_gen_curr_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">]:</span>
                    <span class="n">idx_first_nrn_of_pop</span> <span class="o">=</span> <span class="n">p_util</span><span class="o">.</span><span class="n">get_abs_from_rel_nrn_idx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">n_per_pop</span><span class="p">)</span>
                    <span class="n">idx_last_nrn_of_pop</span> <span class="o">=</span> <span class="n">idx_first_nrn_of_pop</span> <span class="o">+</span> <span class="n">n_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span>
                    <span class="n">I_input</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="n">idx_first_nrn_of_pop</span><span class="p">:</span><span class="n">idx_last_nrn_of_pop</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">I_input_prev</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="n">idx_first_nrn_of_pop</span><span class="p">:</span><span class="n">idx_last_nrn_of_pop</span><span class="p">]</span>
        <span class="n">timer_input_end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="n">log_message</span> <span class="o">=</span> <span class="s2">&quot;Input currents generated in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">timer_input_end</span> <span class="o">-</span> <span class="n">timer_input_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># generate zero current</span>
        <span class="n">input_currents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
            <span class="n">input_currents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">generate_current</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="mi">0</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span>
                                                   <span class="n">n_neurons</span><span class="o">=</span><span class="n">n_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">]))</span>
        <span class="n">I_input</span> <span class="o">=</span> <span class="n">timedarray_from_current</span><span class="p">(</span><span class="n">input_currents</span><span class="p">,</span> <span class="n">unit_time</span><span class="o">=</span><span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;input_current&#39;</span><span class="p">)</span>
        <span class="n">log_message</span> <span class="o">=</span> <span class="s2">&quot;As &#39;input_current&#39; in config is empty, zero currents were generated for all populations.&quot;</span>

    <span class="k">return</span> <span class="n">I_input</span><span class="p">,</span> <span class="n">log_message</span></div>


<div class="viewcode-block" id="generate_current"><a class="viewcode-back" href="../p_input.html#p_input.generate_current">[docs]</a><span class="k">def</span> <span class="nf">generate_current</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="p">,</span> <span class="n">unit_time</span><span class="p">,</span> <span class="n">amplitude_start</span><span class="p">,</span> <span class="n">amplitude_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_neurons</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">offset_range</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">b2</span><span class="o">.</span><span class="n">nA</span><span class="p">,</span> <span class="n">offset_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wnoise_cv</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">wnoise_dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">white_noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">b_power_ramp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate input current as numpy.array. t_start and amplitude_start must be ints/Quantities or lists with the same</span>
<span class="sd">    number of elements. Each element corresponds to one step current or ramp current in a sequence of currents.</span>
<span class="sd">    Elements must be ordered ascending in time. Returned array has n_neurons. Columns are identical if offset_range==0.</span>
<span class="sd">    </span>
<span class="sd">    :param t_start: integer or float or list of integers/floats with start times of current</span>
<span class="sd">    :type t_start: int or float or list</span>
<span class="sd">    :param sim_time_ms: duration of simulation in milliseconds</span>
<span class="sd">    :type sim_time_ms: int or float</span>
<span class="sd">    :param unit_time: brian2 unit of time step (dt between successive current values), e.g. 0.1*b2.ms. Ideally, to have</span>
<span class="sd">        the same time step as the simulation, set this to b2.defaultclock.dt. Can be set to longer, esp. without ramps.</span>
<span class="sd">    :type unit_time: b2.units.fundamentalunits.Quantity [unit=sec]</span>
<span class="sd">    :param amplitude_start: quantity or list of quantities (unit: ampere) of amplitudes at t_start.</span>
<span class="sd">    :type amplitude_start: b2.units.fundamentalunits.Quantity [unit=amp] or list</span>
<span class="sd">    :param amplitude_end: [default=None] quantity or list of quantities of amplitudes at t_end. Generated current</span>
<span class="sd">        ramps from amplitude_start at t_start to amplitude_end at t_end. If amplitude_end is None, [] or empty np.array,</span>
<span class="sd">        it is set to amplitude_start, i.e. only constant step currents are generated.</span>
<span class="sd">    :type amplitude_end: b2.units.fundamentalunits.Quantity [unit=amp] or list or None</span>
<span class="sd">    :param n_neurons: [default=1] number of neurons == number of columns in the returned current array</span>
<span class="sd">    :type n_neurons: int</span>
<span class="sd">    :param offset_range: [default=0] the given current amplitude gets offset by a random value within offset_range.</span>
<span class="sd">        Random values are normally distributed and can exceed these limits! (code for uniformly</span>
<span class="sd">        distributed random offsets commented out below)</span>
<span class="sd">    :type offset_range: b2.units.fundamentalunits.Quantity [unit=amp]</span>
<span class="sd">    :param offset_noise: [default=None] numpy array of random numbers used in randomly offsetting current amplitudes.</span>
<span class="sd">        Empty list: no offsets</span>
<span class="sd">    :type offset_noise: numpy.ndarray or list</span>
<span class="sd">    :param wnoise_cv: [default=0] coefficient of variation for white noise added to full current</span>
<span class="sd">    :type wnoise_cv: float</span>
<span class="sd">    :param wnoise_dt: time in milliseconds between successive random changes in input current according to white_noise</span>
<span class="sd">    :type wnoise_dt: float or int</span>
<span class="sd">    :param white_noise: [default=None] list of numpy arrays (n_neurons) of random numbers used for additive white noise</span>
<span class="sd">    :type white_noise: list</span>
<span class="sd">    :param b_power_ramp: [default=None] None or list of bools of len(t_start). where True or 1, ramp currents increase</span>
<span class="sd">        with power 2 instead of a linear ramp</span>
<span class="sd">    :type b_power_ramp: list or None</span>
<span class="sd">    :return: current: numpy.array to be used as input_current to model neurons. Convert to b2.TimedArray before use,</span>
<span class="sd">        using p_input.timedarray_from_current()</span>
<span class="sd">    :rtype: brian2.units.fundamentalunits.Quantity [unit=amp]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if amplitude_end is None, set it to amplitude_start (i.e. only generate step currents)</span>
    <span class="k">if</span> <span class="n">amplitude_end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">amplitude_end</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">amplitude_end</span> <span class="o">=</span> <span class="n">amplitude_start</span>

    <span class="c1"># if t_start, amplitude_start and amplitude_end are single values of the correct type, convert to lists</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t_start</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_start</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">amplitude_start</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">amplitude_end</span><span class="p">)</span> <span class="ow">is</span> <span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">fundamentalunits</span><span class="o">.</span><span class="n">Quantity</span><span class="p">:</span>
        <span class="n">amplitude_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">amplitude_start</span><span class="p">]</span>
        <span class="n">amplitude_end</span> <span class="o">=</span> <span class="p">[</span><span class="n">amplitude_end</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">b_power_ramp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b_power_ramp</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">b_power_ramp</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_power_ramp</span><span class="p">]</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">t_start</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">t_start</span><span class="p">),</span> \
        <span class="s2">&quot;t_start must be int or float or list of ints/floats&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">unit_time</span><span class="p">)</span> <span class="ow">is</span> <span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">fundamentalunits</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span> <span class="s2">&quot;unit_time must be a b2 Quantity with unit seconds&quot;</span>
    <span class="k">assert</span> <span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">fundamentalunits</span><span class="o">.</span><span class="n">have_same_dimensions</span><span class="p">(</span><span class="n">amplitude_start</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span><span class="p">),</span> \
        <span class="s2">&quot;amplitude_start must have unit of current, e.g. b2.namp&quot;</span>
    <span class="k">assert</span> <span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">fundamentalunits</span><span class="o">.</span><span class="n">have_same_dimensions</span><span class="p">(</span><span class="n">amplitude_end</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span><span class="p">),</span> \
        <span class="s2">&quot;amplitude_end must have unit of current, e.g. b2.namp&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_start</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">amplitude_start</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">amplitude_end</span><span class="p">),</span> \
        <span class="s2">&quot;t_start, amplitude_start and (optional) amplitude_end must all have the same number of elements&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">t_start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t_start</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_start</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> \
        <span class="s2">&quot;t_start must be ordered ascending in time, (amplitude_start must be ordered correspondingly&quot;</span>

    <span class="c1"># get simulation time step and calculate the number of time steps in one millisecond</span>
    <span class="n">steps_per_ms</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">unit_time</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>

    <span class="c1"># initialize current with zeros</span>
    <span class="n">current_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sim_time_ms</span> <span class="o">*</span> <span class="n">steps_per_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 for t=0, +1 for trailing 0</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">current_size</span><span class="p">,</span> <span class="n">n_neurons</span><span class="p">))</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span>

    <span class="c1"># loop through passed elements</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_start</span><span class="p">)):</span>
        <span class="c1"># if amplitude is zero for both start and end: skip this loop iteration</span>
        <span class="k">if</span> <span class="n">amplitude_end</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># calculate the first and last index to the current array corresponding to t_start</span>
        <span class="n">i_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">steps_per_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># if another entry in t_start follow, then that is the end of this current. if not, the end of the simulation is</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_start</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t_start</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">steps_per_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sim_time_ms</span> <span class="o">*</span> <span class="n">steps_per_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">n_steps</span> <span class="o">=</span> <span class="n">i_end</span> <span class="o">-</span> <span class="n">i_start</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">amplitude_end</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="c1"># generate upward ramp current with different random offset for each neuron (but same for start and end)</span>
            <span class="k">if</span> <span class="n">offset_range</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">offset_noise</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offset_noise</span><span class="p">))])</span> <span class="ow">and</span> <span class="n">offset_range</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">nrn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">):</span>
                    <span class="n">current_offset</span> <span class="o">=</span> <span class="n">offset_range</span> <span class="o">*</span> <span class="n">offset_noise</span><span class="p">[</span><span class="n">c</span><span class="o">*</span><span class="n">n_neurons</span> <span class="o">+</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">amp_start_randomized</span> <span class="o">=</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">current_offset</span>
                    <span class="n">amp_end_randomized</span> <span class="o">=</span> <span class="n">amplitude_end</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">current_offset</span>
                    <span class="n">amp_diff</span> <span class="o">=</span> <span class="n">amp_end_randomized</span> <span class="o">-</span> <span class="n">amp_start_randomized</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">b_power_ramp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b_power_ramp</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                        <span class="n">ramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">n_steps</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">amp_diff</span> <span class="o">+</span> <span class="n">amp_start_randomized</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="p">])</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">slope</span> <span class="o">=</span> <span class="n">amp_diff</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>
                        <span class="n">ramp</span> <span class="o">=</span> <span class="n">amp_start_randomized</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">slope</span>
                    <span class="n">current</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span> <span class="n">i_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">=</span> <span class="n">ramp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">amp_diff</span> <span class="o">=</span> <span class="n">amplitude_end</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">b_power_ramp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b_power_ramp</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">ramp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">n_steps</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">amp_diff</span> <span class="o">+</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="p">])</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slope</span> <span class="o">=</span> <span class="n">amp_diff</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>
                    <span class="n">ramp</span> <span class="o">=</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">slope</span>
                <span class="k">for</span> <span class="n">nrn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">):</span>
                    <span class="n">current</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span> <span class="n">i_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">=</span> <span class="n">ramp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">offset_range</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">offset_noise</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offset_noise</span><span class="p">))])</span> <span class="ow">and</span> <span class="n">offset_range</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># generate step current with different random offset within offset_range for each neuron</span>
                <span class="k">for</span> <span class="n">nrn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">):</span>
                    <span class="n">current_offset</span> <span class="o">=</span> <span class="n">offset_range</span> <span class="o">*</span> <span class="n">offset_noise</span><span class="p">[</span><span class="n">c</span><span class="o">*</span><span class="n">n_neurons</span> <span class="o">+</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">amp_start_randomized</span> <span class="o">=</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">current_offset</span>
                    <span class="n">current</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span> <span class="n">i_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp_start_randomized</span>
                    <span class="c1"># for uniform distribution: amplitude_start[c] + offset_range * b2.rand() - offset_range / 2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># generate same step current for all neurons</span>
                <span class="n">current</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span> <span class="n">i_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">amplitude_start</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

    <span class="c1"># add white noise</span>
    <span class="k">if</span> <span class="n">wnoise_cv</span> <span class="ow">and</span> <span class="n">white_noise</span> <span class="ow">and</span> <span class="n">wnoise_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">nrn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">):</span>
            <span class="n">white_noise_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">white_noise</span><span class="p">[</span><span class="n">nrn</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">white_noise</span><span class="p">[</span><span class="n">nrn</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                                                <span class="nb">int</span><span class="p">(</span><span class="n">wnoise_dt</span> <span class="o">/</span> <span class="p">(</span><span class="n">unit_time</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">))),</span>
                                               <span class="p">[</span><span class="n">white_noise</span><span class="p">[</span><span class="n">nrn</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
            <span class="n">current</span><span class="p">[:,</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">[:,</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">+</span> <span class="n">current</span><span class="p">[:,</span> <span class="n">nrn</span><span class="p">]</span> <span class="o">*</span> <span class="n">wnoise_cv</span> <span class="o">*</span> <span class="n">white_noise_full</span>

    <span class="k">return</span> <span class="n">current</span></div>


<div class="viewcode-block" id="timedarray_from_current"><a class="viewcode-back" href="../p_input.html#p_input.timedarray_from_current">[docs]</a><span class="k">def</span> <span class="nf">timedarray_from_current</span><span class="p">(</span><span class="n">currents</span><span class="p">,</span> <span class="n">unit_time</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bundle multiple current arrays returned by p_input.generate_current() into a brian2.TimedArray.</span>

<span class="sd">    :param currents: (list of) numpy.array(s) returned by p_input.generate_current(), one for each neuron/-group</span>
<span class="sd">    :type currents: b2.units.fundamentalunits.Quantity [unit=amp] or list</span>
<span class="sd">    :param unit_time: brian2 unit of time step (dt between successive current values), e.g. 0.1*b2.ms. Ideally, to have</span>
<span class="sd">        the same time step as the simulation, set this to b2.defaultclock.dt (might not work otherwise).</span>
<span class="sd">    :type unit_time: b2.units.fundamentalunits.Quantity [unit=sec]</span>
<span class="sd">    :param name: [default: None] sets name parameter for returned brian2.TimedArray</span>
<span class="sd">    :type name: str or None</span>
<span class="sd">    :param pad_to_length: [default=None] currents will be padded with zeros to this length (i.e. number of time steps)</span>
<span class="sd">    :type pad_to_length: int or None</span>
<span class="sd">    :return: timed_array_current: brian2.TimedArray containing all passed currents</span>
<span class="sd">    :rtype: brian2.input.timedarray.TimedArray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if currents is a single value of the correct type, convert it to a list</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">currents</span><span class="p">)</span> <span class="ow">is</span> <span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">fundamentalunits</span><span class="o">.</span><span class="n">Quantity</span><span class="p">:</span>
        <span class="n">currents</span> <span class="o">=</span> <span class="p">[</span><span class="n">currents</span><span class="p">]</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">unit_time</span><span class="p">)</span> <span class="ow">is</span> <span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">fundamentalunits</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span> <span class="s2">&quot;unit_time must be a b2 Quantity with unit seconds&quot;</span>
    <span class="k">assert</span> <span class="p">[</span><span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">fundamentalunits</span><span class="o">.</span><span class="n">have_same_dimensions</span><span class="p">(</span><span class="n">currents</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">currents</span><span class="p">))],</span> \
        <span class="s2">&quot;currents must have unit of current, e.g. b2.namp&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;name must be a string or None&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">pad_to_length</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">pad_to_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;pad_to_length must be an int or None&quot;</span>

    <span class="c1"># determine maximum length of currents for padding, unless pad_to_length was passed</span>
    <span class="k">if</span> <span class="n">pad_to_length</span><span class="p">:</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="n">pad_to_length</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">currents</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">currents</span><span class="p">))])</span>

    <span class="c1"># construct numpy.array to hold all currents from passed list</span>
    <span class="n">n_current_columns</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">currents</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">currents</span><span class="p">))])</span>
    <span class="n">numpy_array_current</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_length</span><span class="p">,</span> <span class="n">n_current_columns</span><span class="p">))</span>

    <span class="c1"># loop through currents and pad with zero, so that all have the same length</span>
    <span class="n">next_col</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">currents</span><span class="p">)):</span>
        <span class="n">last_col</span> <span class="o">=</span> <span class="n">next_col</span><span class="o">+</span><span class="n">currents</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">numpy_array_current</span><span class="p">[:,</span> <span class="n">next_col</span><span class="p">:</span><span class="n">last_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">currents</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_length</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">currents</span><span class="p">[</span><span class="n">c</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                                                           <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="n">next_col</span> <span class="o">+=</span> <span class="n">currents</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># add unit</span>
    <span class="n">numpy_array_current</span> <span class="o">=</span> <span class="n">numpy_array_current</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">amp</span>

    <span class="c1"># convert to b2.TimedArray and return</span>
    <span class="n">timed_array_current</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">TimedArray</span><span class="p">(</span><span class="n">numpy_array_current</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">unit_time</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">timed_array_current</span></div>


<div class="viewcode-block" id="load_spiketimes_for_gen"><a class="viewcode-back" href="../p_input.html#p_input.load_spiketimes_for_gen">[docs]</a><span class="k">def</span> <span class="nf">load_spiketimes_for_gen</span><span class="p">(</span><span class="n">path_to_spiketimes</span><span class="p">,</span> <span class="n">neuron_nrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace_nrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">population_nrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">recording_offsets_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b_single_population</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load spiketimes from recordings of specific neurons to use as input for SpikegeneratorGroups.</span>

<span class="sd">    :param path_to_spiketimes: path to directory containing spiketimes pickle files (.pkl)</span>
<span class="sd">    :type path_to_spiketimes: str</span>
<span class="sd">    :param neuron_nrs: [default=None] list of integer indices to neurons from which spiketimes should be loaded.</span>
<span class="sd">        1-based indexing of alphanumerically sorted .pkl filenames in path_to_spiketimes. None: load from all files</span>
<span class="sd">    :type neuron_nrs: [int] or None</span>
<span class="sd">    :param trace_nrs: [default=None] list of list(s) of integer indices to traces of the respective neuron (one sublist</span>
<span class="sd">        per neuron) from which spiketimes should be loaded. 1-based indexing. None: load from all traces</span>
<span class="sd">    :type trace_nrs: [[int]] or None</span>
<span class="sd">    :param population_nrs: [default=None] list of integer identifiers for grouping neurons into populations (used for</span>
<span class="sd">        spikegenerator populations), one integer per neuron. Must be in ascending order. None: either all neurons belong</span>
<span class="sd">        to the same population, or each neuron is part of its own population, depending on b_single_population</span>
<span class="sd">    :type population_nrs: [int] or None</span>
<span class="sd">    :param recording_offsets_ms: [default=None] list of offsets in milliseconds, which will be added to spiketimes to</span>
<span class="sd">        account for differential alignment. one offset per neuron. if None, offset will be zero for all neurons</span>
<span class="sd">    :type recording_offsets_ms: [float] or None</span>
<span class="sd">    :param b_single_population: [default=False] if True, all neurons will be put in a single sublist, i.e. will belong</span>
<span class="sd">        to a single spikegenerator population when passed to run_simulation(). Otherwise each .pkl file will (e.g.</span>
<span class="sd">        recorded neuron) will make up a seperate sublist / spikegenerator population. If population_nrs is not None,</span>
<span class="sd">        this parameter is ignored</span>
<span class="sd">    :type b_single_population: bool</span>
<span class="sd">    :return: input_spiketimes_ms: list of list(s) of list(s) of spike times in milliseconds. one sublist per</span>
<span class="sd">        generator population (corresponds to model neuron population), one subsublist per trace, i.e. generator</span>
<span class="sd">        neuron. To be passed to run_simulation() for creation of spikegenerator groups</span>
<span class="sd">    :rtype: [[[float]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get names of all .pkl files in the supplied path and sort them alphanumerically</span>
    <span class="n">spiketimes_filenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_to_spiketimes</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_spiketimes</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                            <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)]</span>
    <span class="n">spiketimes_filenames</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="c1"># if no neuron numbers were passed, use all .pkl files found in directory</span>
    <span class="k">if</span> <span class="n">neuron_nrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neuron_nrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_filenames</span><span class="p">))]</span>

    <span class="c1"># if no recording_offsets were passed, set all to zero</span>
    <span class="k">if</span> <span class="n">recording_offsets_ms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">recording_offsets_ms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_nrs</span><span class="p">)</span>

    <span class="c1"># if no population_nrs were passed, use the same for all neurons, or one population per neuron</span>
    <span class="k">if</span> <span class="n">population_nrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b_single_population</span><span class="p">:</span>
            <span class="n">population_nrs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_nrs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">population_nrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_nrs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">neuron_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">neuron_nrs</span><span class="p">),</span> \
        <span class="s2">&quot;neuron_nrs must be a list of integer indices to neurons from which to load spiketimes (1-based indexing).&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">trace_nrs</span><span class="p">),</span> \
        <span class="s2">&quot;trace_nrs must be a list of lists of integer indices to traces, one sublist per trace (1-based indexing).&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">[</span><span class="n">sublist</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">[</span><span class="n">sublist</span><span class="p">]))</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">))),</span> \
        <span class="s2">&quot;sublists of trace_nrs may not contain duplicates&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">population_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">population_nrs</span><span class="p">),</span> \
        <span class="s2">&quot;population_nrs must be a list of integer indices to populations for grouping neurons (1-based indexing).&quot;</span>
    <span class="k">assert</span> <span class="n">population_nrs</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population_nrs</span><span class="p">),</span> <span class="s2">&quot;population_nrs must be in ascending order (e.g. [1, 1, 2, 3])&quot;</span>
    <span class="k">if</span> <span class="n">trace_nrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">population_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">recording_offsets_ms</span><span class="p">),</span> \
            <span class="s2">&quot;neuron_nrs, trace_nrs, population_nrs and recording_offsets_ms must have the same number of elements&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">population_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">recording_offsets_ms</span><span class="p">),</span> \
            <span class="s2">&quot;neuron_nrs, population_nrs and recording_offsets_ms must have the same number of elements&quot;</span>

    <span class="c1"># loop through populations</span>
    <span class="n">input_spiketimes_ms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">population_nrs</span><span class="p">):</span>
        <span class="n">spiketimes_cur_pop</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i_cur_pop</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">population_nrs</span><span class="p">))</span> <span class="k">if</span> <span class="n">population_nrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pop</span><span class="p">]</span>
        <span class="n">neuron_nrs_cur_pop</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_nrs</span><span class="p">[</span><span class="n">i_cur_pop</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_cur_pop</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">neuron_nr_cur</span> <span class="ow">in</span> <span class="n">neuron_nrs_cur_pop</span><span class="p">:</span>
            <span class="n">spiketimes_cur_nrn</span> <span class="o">=</span> <span class="n">p_io</span><span class="o">.</span><span class="n">load_spiketimes_from_pkl</span><span class="p">(</span><span class="n">path_to_spiketimes</span> <span class="o">+</span>
                                                               <span class="n">spiketimes_filenames</span><span class="p">[</span><span class="n">neuron_nr_cur</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if trace_nrs is not None, delete all traces from input_spiketimes_ms not in current sublist of trace_nr</span>
            <span class="k">if</span> <span class="n">trace_nrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># loop through traces in reverse order following and delete those not in trace_nrs</span>
                <span class="c1"># (deleting in normal order would invalidate the following indices)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_cur_nrn</span><span class="p">)),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trace_nrs</span><span class="p">[</span><span class="n">neuron_nrs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">neuron_nr_cur</span><span class="p">)]:</span>
                        <span class="k">del</span> <span class="n">spiketimes_cur_nrn</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
            <span class="n">rec_off_cur</span> <span class="o">=</span> <span class="n">recording_offsets_ms</span><span class="p">[</span><span class="n">neuron_nrs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">neuron_nr_cur</span><span class="p">)]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;| loaded spiketimes of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_cur_nrn</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; traces for population &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span> <span class="o">+</span>
                  <span class="s2">&quot; from &quot;</span> <span class="o">+</span> <span class="n">spiketimes_filenames</span><span class="p">[</span><span class="n">neuron_nr_cur</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">spiketimes_cur_nrn</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">rec_off_cur</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spiketimes_cur_nrn</span> <span class="o">=</span> <span class="p">[[</span><span class="n">trc</span><span class="p">[</span><span class="n">spk</span><span class="p">]</span> <span class="o">+</span> <span class="n">rec_off_cur</span> <span class="k">for</span> <span class="n">spk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trc</span><span class="p">))]</span> <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="n">spiketimes_cur_nrn</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2"> spiketimes offset by &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rec_off_cur</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; ms.&quot;</span><span class="p">)</span>
            <span class="n">spiketimes_cur_pop</span> <span class="o">=</span> <span class="n">spiketimes_cur_pop</span> <span class="o">+</span> <span class="n">spiketimes_cur_nrn</span>
        <span class="n">input_spiketimes_ms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spiketimes_cur_pop</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">input_spiketimes_ms</span></div>


<div class="viewcode-block" id="get_rates_for_poisson_group"><a class="viewcode-back" href="../p_input.html#p_input.get_rates_for_poisson_group">[docs]</a><span class="k">def</span> <span class="nf">get_rates_for_poisson_group</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">log_name</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate and return brian2.TimedArray of spike rates for a Poisson Group, based on specifications in</span>
<span class="sd">    config (e.g. loaded from .json config file), namely config[&#39;poisson_group&#39;].</span>

<span class="sd">    :param config: dictionary of model parameters as loaded from .json configuration file</span>
<span class="sd">    :type config: dict</span>
<span class="sd">    :param log_name: name of logger object (standard python logging) created earlier, e.g. through p_io.set_up_loggers()</span>
<span class="sd">    :type log_name: str</span>
<span class="sd">    :param sim_time_ms: [default=None] duration of simulation in milliseconds. if None: load from config file</span>
<span class="sd">    :type sim_time_ms: int or None</span>
<span class="sd">    :return: timed_array_poisson_rate: Timed Array of spike rates at each time point of the simulation in Hz</span>
<span class="sd">    :rtype: brian2.TimedArray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">,</span> <span class="s2">&quot;p_input.setup_currents(): argument config must be dictionary (as loaded from .json)&quot;</span>
    <span class="k">assert</span> <span class="n">sim_time_ms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sim_time_ms</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sim_time_ms</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> \
        <span class="s2">&quot;argument &#39;sim_time_ms&#39; must be an integer &gt;= 0 or None&quot;</span>

    <span class="c1"># misc parameters</span>
    <span class="k">if</span> <span class="n">sim_time_ms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sim_time_ms</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;sim_time&#39;</span><span class="p">]</span>

    <span class="c1"># get logger object</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">log_name</span><span class="p">)</span>

    <span class="c1"># generate timed array of firing rates for a Poisson Group</span>
    <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">]:</span>
        <span class="c1"># check if all rates are applied within simulation time</span>
        <span class="k">for</span> <span class="n">t_rate_end</span> <span class="ow">in</span> <span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;duration&#39;</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">]))]:</span>
            <span class="k">if</span> <span class="n">t_rate_end</span> <span class="o">&gt;</span> <span class="n">sim_time_ms</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;WARNING: firing rates for poisson group extend beyond simulation time (&quot;</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">sim_time_ms</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ms)!&quot;</span><span class="p">)</span>
        <span class="n">poisson_group_t_start</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">]</span>
        <span class="n">poisson_group_duration</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span>
        <span class="n">poisson_group_rate_start</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;rate_start&#39;</span><span class="p">]</span>
        <span class="n">poisson_group_rate_end</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;rate_end&#39;</span><span class="p">]</span>

        <span class="c1"># if poisson_group_rate_end is None, set it to poisson_group_rate_start (i.e. only generate step rates)</span>
        <span class="k">if</span> <span class="n">poisson_group_rate_end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">poisson_group_rate_end</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">poisson_group_rate_end</span> <span class="o">=</span> <span class="n">poisson_group_rate_start</span>

        <span class="c1"># get simulation time step and calculate the number of time steps in one millisecond</span>
        <span class="n">steps_per_ms</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>

        <span class="c1"># initialize rate with zeros</span>
        <span class="n">last_rate_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">poisson_group_t_start</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">poisson_group_duration</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poisson_group_t_start</span><span class="p">))])</span>
        <span class="n">rate_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">last_rate_end</span> <span class="o">*</span> <span class="n">steps_per_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 for t=0, +1 for trailing 0</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">rate_size</span><span class="p">)</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">Hz</span>

        <span class="c1"># loop through passed elements</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poisson_group_t_start</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">poisson_group_duration</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if deltaT is zero, we return a zero rate</span>
                <span class="k">continue</span>
            <span class="c1"># calculate the first &amp; last index to the rate array corresponding to t_start &amp; duration for this step/ramp</span>
            <span class="n">i_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">poisson_group_t_start</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">steps_per_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">poisson_group_t_start</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">poisson_group_duration</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="n">steps_per_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">n_steps</span> <span class="o">=</span> <span class="n">i_end</span> <span class="o">-</span> <span class="n">i_start</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">poisson_group_rate_end</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">==</span> <span class="n">poisson_group_rate_start</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                <span class="c1"># generate upward ramping rate</span>
                <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">poisson_group_rate_end</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">poisson_group_rate_start</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>
                <span class="n">ramp</span> <span class="o">=</span> <span class="p">[</span><span class="n">poisson_group_rate_start</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">slope</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">rate</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span> <span class="n">i_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ramp</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">Hz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># generate step rate</span>
                <span class="n">rate</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span> <span class="n">i_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">poisson_group_rate_start</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">Hz</span>

        <span class="c1"># convert to b2.TimedArray and return</span>
        <span class="n">timed_array_poisson_rate</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">TimedArray</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;poisson_rate&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">timed_array_poisson_rate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Philipp Norton.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>