

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>p_analysis &mdash; call-time-model  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/p_theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> call-time-model
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../config_files.html">Config Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">call-time-model</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>p_analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for p_analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Various data analysis functions, including spike detection and analysis of spike data. [call-time-model]</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">brian2</span> <span class="k">as</span> <span class="nn">b2</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>

<span class="c1"># import my functions</span>
<span class="kn">from</span> <span class="nn">fcn</span> <span class="kn">import</span> <span class="n">p_io</span><span class="p">,</span> <span class="n">p_util</span>


<div class="viewcode-block" id="get_spiketimes"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_spiketimes">[docs]</a><span class="k">def</span> <span class="nf">get_spiketimes</span><span class="p">(</span><span class="n">traces</span><span class="p">,</span> <span class="n">sampling_frequency_khz</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">smooth_filter_win_len</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">threshold_factor</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
                   <span class="n">max_ms_thresh_to_peak</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_samp_above_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Detect spiketimes in voltage traces by taking derivative (gradient) of the smoothed trace first.</span>
<span class="sd">    Smoothing uses Savitzky-Golay filter.</span>

<span class="sd">    :param traces: (list of) numpy ndarray(s) of voltage traces</span>
<span class="sd">    :type traces: np.ndarray or list</span>
<span class="sd">    :param sampling_frequency_khz: [default=40] sampling frequency of traces in kHz</span>
<span class="sd">    :type sampling_frequency_khz: int or float</span>
<span class="sd">    :param smooth_filter_win_len: [default=11] length of window for Savitzky-Golay filter</span>
<span class="sd">    :type smooth_filter_win_len: int</span>
<span class="sd">    :param threshold_factor: [default=14] gradient of smoothed trace must cross this factor times the estimated standard</span>
<span class="sd">        deviation of the noise in the absolute values of the gradient for a spike to be detected</span>
<span class="sd">        (see Quian Quiroga et al. (2004), doi:10.1162/089976604774201631)</span>
<span class="sd">    :type threshold_factor: int or float</span>
<span class="sd">    :param max_ms_thresh_to_peak: [default=1] spike peak has to be within this number of milliseconds after threshold</span>
<span class="sd">        crossing of the gradient. Otherwise it will be considered an artifact</span>
<span class="sd">    :type max_ms_thresh_to_peak: int or float</span>
<span class="sd">    :param min_samp_above_thresh: [default=2] gradient must be above threshold for this many consecutive samples to</span>
<span class="sd">        not be considered an artifact</span>
<span class="sd">    :type min_samp_above_thresh: int</span>
<span class="sd">    :return:</span>
<span class="sd">        - spiketimes_samp: list of lists of spike times (in samples). One sublist per trace.</span>
<span class="sd">        - b_spike_matrix: two-dimensional matrix of samples (columns) of traces (rows), where 0 == no spike &amp; 1 == spike</span>
<span class="sd">        - thresholds: voltage threshold per trace for spike detection: trace crosses this from below prior to spike peak</span>
<span class="sd">    :rtype:</span>
<span class="sd">        - spiketimes_samp: [[int]]</span>
<span class="sd">        - b_spike_matrix: np.ndarray</span>
<span class="sd">        - thresholds: [float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if traces contains a single trace, convert it to a list</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">traces</span><span class="p">]</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">),</span> \
        <span class="s2">&quot;traces must be a numpy ndarray or list of ndarrays&quot;</span>

    <span class="c1"># initialize variables</span>
    <span class="n">n_traces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span>
    <span class="n">n_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">traces</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_traces</span><span class="p">)]</span>
    <span class="n">spiketimes_samp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">b_spike_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_traces</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">n_values</span><span class="p">)))</span>
    <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># smooth traces using savitzky-golay filter</span>
    <span class="n">traces_smooth_sg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_traces</span><span class="p">):</span>
        <span class="n">traces_smooth_sg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="n">trc</span><span class="p">],</span> <span class="n">smooth_filter_win_len</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># calculate the derivative (gradient) of each smoothed trace and set negatives value to zero (rectify)</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gradients_rect</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_traces</span><span class="p">):</span>
        <span class="n">gradients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">trc</span><span class="p">]))</span>
        <span class="n">gradients_rect</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">]),</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
        <span class="n">gradients_rect</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># loop through traces and send them to detector</span>
    <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_traces</span><span class="p">):</span>
        <span class="c1"># set threshold</span>
        <span class="n">noise_std_estimation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">])</span> <span class="o">/</span> <span class="mf">0.6745</span><span class="p">)</span>
        <span class="n">threshold_cur</span> <span class="o">=</span> <span class="n">threshold_factor</span> <span class="o">*</span> <span class="n">noise_std_estimation</span>

        <span class="c1"># get spiketimes</span>
        <span class="n">trace_thresh_zero</span> <span class="o">=</span> <span class="n">gradients_rect</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span> <span class="o">-</span> <span class="n">threshold_cur</span>
        <span class="n">b_trace_above_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">trace_thresh_zero</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">b_crosses_thresh</span> <span class="o">=</span> <span class="n">b_trace_above_thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">b_trace_above_thresh</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">i_crossings_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b_crosses_thresh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i_crossings_down</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b_crosses_thresh</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># continue analysis only if there is at least one upward and one downward crossing of the threshold</span>
        <span class="k">if</span> <span class="n">i_crossings_down</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">i_crossings_up</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># if first down crossing comes before first up (i.e. trace started</span>
            <span class="c1"># above threshold), delete that. And vice versa.</span>
            <span class="k">if</span> <span class="n">i_crossings_down</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i_crossings_up</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">i_crossings_down</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">i_crossings_down</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i_crossings_up</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i_crossings_down</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">i_crossings_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">i_crossings_up</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># loop through threshold crossings and get index of maximum gradient</span>
            <span class="n">i_max_g</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i_max_v</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_crossings_up</span><span class="p">)):</span>
                <span class="c1"># make sure gradient stays above threshold for at least 2</span>
                <span class="c1"># samples (to exclude crossings due to noise)</span>
                <span class="k">if</span> <span class="n">i_crossings_down</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">i_crossings_up</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_samp_above_thresh</span><span class="p">:</span>
                    <span class="n">i_max_above_thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gradients_rect</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">i_crossings_up</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span><span class="n">i_crossings_down</span><span class="p">[</span><span class="n">c</span><span class="p">]])</span>
                    <span class="n">i_max_g</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_max_above_thresh</span> <span class="o">+</span> <span class="n">i_crossings_up</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
                    <span class="c1"># find first zero crossing after gradient maximum (i.e. timepoint of maximum smoothed voltage)</span>
                    <span class="n">i_next_zero_crossings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">i_max_g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">i_next_zero_crossings</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">i_next_zero_crossings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">max_ms_thresh_to_peak</span> <span class="o">*</span> <span class="n">sampling_frequency_khz</span><span class="p">:</span>
                            <span class="c1"># check if next zero crossing was already detected with previous threshold crossing and if</span>
                            <span class="c1"># so, ignore this one (otherwise there will be two spikes at detected at the same timepoint)</span>
                            <span class="k">if</span> <span class="n">i_max_v</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">i_max_g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_next_zero_crossings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">i_max_v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">i_max_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_max_g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_next_zero_crossings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="ow">not</span> <span class="n">i_max_v</span><span class="p">:</span>
                                <span class="n">i_max_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_max_g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_next_zero_crossings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; double detection of one spike avoided at trace &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; spike &quot;</span> <span class="o">+</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_max_v</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;(?)&quot;</span><span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; found and ignored peak longer than max_ms_thresh_to_peak=&quot;</span> <span class="o">+</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">max_ms_thresh_to_peak</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; after threshold crossing of gradient at &quot;</span> <span class="o">+</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">i_max_g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sampling_frequency_khz</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ms in trace &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="n">b_spike_matrix</span><span class="p">[</span><span class="n">trc</span><span class="p">,</span> <span class="n">i_max_v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">spiketimes_samp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i_max_v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spiketimes_samp</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="c1"># save threshold</span>
        <span class="n">thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">threshold_cur</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spiketimes_samp</span><span class="p">,</span> <span class="n">b_spike_matrix</span><span class="p">,</span> <span class="n">thresholds</span></div>


<div class="viewcode-block" id="get_onset_of_spikes"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_onset_of_spikes">[docs]</a><span class="k">def</span> <span class="nf">get_onset_of_spikes</span><span class="p">(</span><span class="n">traces</span><span class="p">,</span> <span class="n">spiketimes_ms</span><span class="p">,</span> <span class="n">sampling_frequency_khz</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">thresh_ratio_to_derivative_peak</span><span class="o">=</span><span class="mf">0.066</span><span class="p">,</span>
                        <span class="n">smooth_filter_win_len</span><span class="o">=</span><span class="mi">11</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given voltage trace(s) and corresponding spiketimes (i.e. voltage peaks), determine onsets of each spike (and</span>
<span class="sd">    spike thresholds) by detecting threshold crossing of the derivative of the smoothed membrane voltage,</span>
<span class="sd">    backward from the spike.</span>

<span class="sd">    :param traces: (list of) numpy ndarray(s) of voltage traces</span>
<span class="sd">    :type traces: np.ndarray or list</span>
<span class="sd">    :param spiketimes_ms: list of lists of spike times of the neuron (one sublist per trial, i.e. array in traces)</span>
<span class="sd">    :type spiketimes_ms: [[float]]</span>
<span class="sd">    :param sampling_frequency_khz: [default=40] sampling frequency of traces in kHz</span>
<span class="sd">    :type sampling_frequency_khz: int or float</span>
<span class="sd">    :param thresh_ratio_to_derivative_peak: threshold for the prespike membrane voltage derivative for spike onset /</span>
<span class="sd">        spike threshold detection. this is the ratio of the derivative peak at which the spike is considered to be</span>
<span class="sd">        triggered. See e.g. Azouz &amp; Gray (2000), Trinh et al. (2019). See also Sekerli et al. (2004) for a comparison</span>
<span class="sd">        of detection methods and this and Fontaine et al. (2014) for an absolute threshold instead. Exchange</span>
<span class="sd">        thresh_derivative_mV_per_samp_relative with thresh..._absolute in code below for absolute threshold.</span>
<span class="sd">    :type thresh_ratio_to_derivative_peak: float</span>
<span class="sd">    :param smooth_filter_win_len: [default=11] length of window for Savitzky-Golay filter</span>
<span class="sd">    :type smooth_filter_win_len: int</span>
<span class="sd">    :return:    - spike_onset_times_ms: list of lists of spike onset times in milliseconds</span>
<span class="sd">                - spike_thresholds_mV: list of lists of spike thresholds (voltages at corresponding spike onsets)</span>
<span class="sd">    :rtype:     - spike_onset_times_ms: list</span>
<span class="sd">                - spike_thresholds_mV: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">traces</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms</span><span class="p">),</span> <span class="s2">&quot;arguments traces and spiketimes_ms must have the same number of &quot;</span> \
                                              <span class="s2">&quot;elements (sublists/arrays)&quot;</span>

    <span class="c1"># initialize variables</span>
    <span class="n">n_traces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span>

    <span class="c1"># smooth traces using savitzky-golay filter</span>
    <span class="n">traces_smooth_sg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_traces</span><span class="p">):</span>
        <span class="n">traces_smooth_sg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="n">trc</span><span class="p">],</span> <span class="n">smooth_filter_win_len</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># calculate the derivative (gradient) of each smoothed trace and set negatives value to zero (rectify)</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_traces</span><span class="p">):</span>
        <span class="n">gradients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">trc</span><span class="p">]))</span>

    <span class="c1"># loop through traces and spikes</span>
    <span class="n">spike_onset_times_ms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spike_thresholds_mV</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_traces</span><span class="p">):</span>
        <span class="n">spike_onset_times_ms</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">spike_thresholds_mV</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">t_spike</span> <span class="ow">in</span> <span class="n">spiketimes_ms</span><span class="p">[</span><span class="n">trc</span><span class="p">]:</span>
            <span class="c1"># find derivative maximum in the 1ms before spike</span>
            <span class="n">samp_spike</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_spike</span> <span class="o">*</span> <span class="n">sampling_frequency_khz</span><span class="p">))</span>
            <span class="n">samp_1ms_prespike</span> <span class="o">=</span> <span class="n">samp_spike</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">sampling_frequency_khz</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">samp_1ms_prespike</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;! Onset calculation for spike within first ms skipped in trace &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trc</span><span class="p">))</span>
                <span class="n">spike_onset_times_ms</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">spike_thresholds_mV</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">gradient_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">samp_spike</span><span class="p">:</span><span class="n">samp_1ms_prespike</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">samp_gradient_peak_from_spike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">samp_spike</span><span class="p">:</span><span class="n">samp_1ms_prespike</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">samp_gradient_peak</span> <span class="o">=</span> <span class="n">samp_spike</span> <span class="o">-</span> <span class="n">samp_gradient_peak_from_spike</span>
            <span class="c1"># find first threshold corssing of gradient backwards from peak</span>
            <span class="n">thresh_derivative_mV_per_samp_absolute</span> <span class="o">=</span> <span class="mi">25</span> <span class="o">/</span> <span class="n">sampling_frequency_khz</span>
            <span class="c1"># threshold relative to gradient peak</span>
            <span class="n">thresh_derivative_mV_per_samp_relative</span> <span class="o">=</span> <span class="n">gradient_peak</span> <span class="o">*</span> <span class="n">thresh_ratio_to_derivative_peak</span>
            <span class="n">samp_1ms_prepeak</span> <span class="o">=</span> <span class="n">samp_gradient_peak</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">sampling_frequency_khz</span><span class="p">))</span>
            <span class="n">thresh_crossings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">gradients</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">samp_gradient_peak</span><span class="p">:</span><span class="n">samp_1ms_prepeak</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                          <span class="o">&lt;</span> <span class="n">thresh_derivative_mV_per_samp_relative</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">thresh_crossings</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">samp_thresh_crossing_from_peak</span> <span class="o">=</span> <span class="n">thresh_crossings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">samp_spike_onset</span> <span class="o">=</span> <span class="n">samp_gradient_peak</span> <span class="o">-</span> <span class="n">samp_thresh_crossing_from_peak</span>
                <span class="n">spike_onset_times_ms</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">samp_spike_onset</span> <span class="o">/</span> <span class="n">sampling_frequency_khz</span><span class="p">)</span>
                <span class="n">spike_thresholds_mV</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">trc</span><span class="p">][</span><span class="n">samp_spike_onset</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spike_onset_times_ms</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">spike_thresholds_mV</span><span class="p">[</span><span class="n">trc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;INFO: Spike onset not detectable&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spike_onset_times_ms</span><span class="p">,</span> <span class="n">spike_thresholds_mV</span></div>


<div class="viewcode-block" id="get_rise_time"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_rise_time">[docs]</a><span class="k">def</span> <span class="nf">get_rise_time</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">i_peak</span><span class="p">,</span> <span class="n">i_onset</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">sampling_frequency_khz</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given the index of a peak (e.g. PSP or spike) in a trace and the index of the onset of the rise (i.e. spike</span>
<span class="sd">    or PSP onset), return the time in ms it takes to reach a certain amplitude percentage from baseline (i.e. value of</span>
<span class="sd">    trace at onset, e.g. in mV). Also return the index in the trace that corresponds to this timepoint.</span>
<span class="sd">    percent == 100: peak amplitude</span>

<span class="sd">    :param trace: numpy ndarray of e.g. voltage trace</span>
<span class="sd">    :type trace: np.ndarray</span>
<span class="sd">    :param i_peak: index of the peak of interest in trace</span>
<span class="sd">    :type i_peak: int</span>
<span class="sd">    :param i_onset: index of the onset of the event of interest in trace (e.g. PSP or spike onset)</span>
<span class="sd">    :type i_onset: int</span>
<span class="sd">    :param percent: [default=100] percentage of peak amplitude relative to baseline (amplitude at i_onset) to reach</span>
<span class="sd">    :type percent: int or float</span>
<span class="sd">    :param sampling_frequency_khz: [default=40] sampling frequency of traces in kHz</span>
<span class="sd">    :type sampling_frequency_khz: int or float</span>
<span class="sd">    :return:    - t_rise: time from onset to reach x percent of the peak amplitude in milliseconds</span>
<span class="sd">                - i_percent: index to trace of the timepoint when trace reaches x percent of the peak</span>
<span class="sd">    :rtype:     - t_rise: float</span>
<span class="sd">                - i_percent: int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="n">i_onset</span> <span class="o">&lt;</span> <span class="n">i_peak</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="p">),</span> <span class="s2">&quot;get_rise_time(): condition [i_onset &lt; i_peak &lt; len(trace)] not met&quot;</span>

    <span class="c1"># if 100 percent rise time, just return the time difference between peak and onset</span>
    <span class="k">if</span> <span class="n">percent</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">t_rise</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_peak</span> <span class="o">-</span> <span class="n">i_onset</span><span class="p">)</span> <span class="o">/</span> <span class="n">sampling_frequency_khz</span>
        <span class="n">i_percent</span> <span class="o">=</span> <span class="n">i_peak</span>
        <span class="k">return</span> <span class="n">t_rise</span><span class="p">,</span> <span class="n">i_percent</span>

    <span class="c1"># get amplitude of interest (x percent of the difference between peak and onset)</span>
    <span class="n">peak_amp</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="n">i_peak</span><span class="p">]</span>
    <span class="n">onset_amp</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="n">i_onset</span><span class="p">]</span>
    <span class="n">amp_at_x_perc</span> <span class="o">=</span> <span class="n">onset_amp</span> <span class="o">+</span> <span class="p">(</span><span class="n">peak_amp</span> <span class="o">-</span> <span class="n">onset_amp</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">percent</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>

    <span class="c1"># get timepoint where amplitude first exceeds the percentage after onset</span>
    <span class="k">if</span> <span class="n">peak_amp</span> <span class="o">&gt;</span> <span class="n">onset_amp</span><span class="p">:</span>
        <span class="n">i_percent_from_onset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="n">i_onset</span><span class="p">:</span><span class="n">i_peak</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">amp_at_x_perc</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i_percent_from_onset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="n">i_onset</span><span class="p">:</span><span class="n">i_peak</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">amp_at_x_perc</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># if the amplitude of interest is closer to the sample before the crossing, use that instead</span>
    <span class="c1"># (i.e. round rise time to nearest sample)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">amp_at_x_perc</span> <span class="o">-</span> <span class="n">trace</span><span class="p">[</span><span class="n">i_percent_from_onset</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">amp_at_x_perc</span> <span class="o">-</span> <span class="n">trace</span><span class="p">[</span><span class="n">i_percent_from_onset</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">i_percent_from_onset</span> <span class="o">=</span> <span class="n">i_percent_from_onset</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># get time from onset to reach that point</span>
    <span class="n">t_rise</span> <span class="o">=</span> <span class="n">i_percent_from_onset</span> <span class="o">/</span> <span class="n">sampling_frequency_khz</span>
    <span class="n">i_percent</span> <span class="o">=</span> <span class="n">i_onset</span> <span class="o">+</span> <span class="n">i_percent_from_onset</span>

    <span class="k">return</span> <span class="n">t_rise</span><span class="p">,</span> <span class="n">i_percent</span></div>


<div class="viewcode-block" id="remove_spikes"><a class="viewcode-back" href="../p_analysis.html#p_analysis.remove_spikes">[docs]</a><span class="k">def</span> <span class="nf">remove_spikes</span><span class="p">(</span><span class="n">filename_pkl</span><span class="p">,</span> <span class="n">trace_nrs</span><span class="p">,</span> <span class="n">spike_nrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Opens .pkl file that contains spiketimes of a recording, deletes the spiketimes given by the trace and spike</span>
<span class="sd">    indices, overwrites the .pkl file with the modified spiketimes. Call manually to remove false positives.</span>

<span class="sd">    :param filename_pkl: filename of .pkl file containing spiketimes</span>
<span class="sd">    :type filename_pkl: str</span>
<span class="sd">    :param trace_nrs: list of integer indices to traces in which spikes are to be deleted. 1-based indexing, i.e. [1]</span>
<span class="sd">        refers to the first trace and therefore to spiketimes[0]</span>
<span class="sd">    :type trace_nrs: [int]</span>
<span class="sd">    :param spike_nrs: list of list of indices to the chronologically ordered spikes. one sublist per trace in i_traces.</span>
<span class="sd">        1-based indexing. Example: remove_spikes(&#39;bla.pkl&#39;, [1, 3], [[1, 2], [1, 2, 3]]) removes the first two spikes in</span>
<span class="sd">        the first trace and the first three spikes in the third trace, i.e. spiketimes[0][0:2] and spiketimes[2][0:3]</span>
<span class="sd">    :type spike_nrs: [[int]]</span>
<span class="sd">    :return:</span>
<span class="sd">        - spiketimes_ms_modified: the list of spiketimes with spikes removed</span>
<span class="sd">        - spiketimes_ms_loaded: the original (unmodified) list of spiketimes (in milliseconds) from the .pkl file</span>
<span class="sd">    :rtype:</span>
<span class="sd">        - spiketimes_ms_modified: [[float]]</span>
<span class="sd">        - spiketimes_ms_loaded: [[float]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># load spiketimes from pickle file</span>
    <span class="n">spiketimes_ms_loaded</span> <span class="o">=</span> <span class="n">p_io</span><span class="o">.</span><span class="n">load_spiketimes_from_pkl</span><span class="p">(</span><span class="n">filename_pkl</span><span class="p">)</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">trace_nrs</span><span class="p">),</span> \
        <span class="s2">&quot;trace_nrs must be a list of integer indices to traces in which spikes are to be deleted (1-based indexing).&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">spike_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">spike_nrs</span><span class="p">),</span> \
        <span class="s2">&quot;spike_nrs must be a list of lists of integer indices to spikes, one sublist per trace (1-based indexing).&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_nrs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">),</span> <span class="s2">&quot;spike_nrs must have the same number of sublists as trace_nrs has elements&quot;</span>

    <span class="c1"># remove spikes</span>
    <span class="n">spiketimes_ms_modified</span> <span class="o">=</span> <span class="n">spiketimes_ms_loaded</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trace_nrs</span><span class="p">):</span>
        <span class="n">i_trc</span> <span class="o">=</span> <span class="n">trc</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># check if indices are correct</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">trc</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms_loaded</span><span class="p">),</span> <span class="s2">&quot;trace index &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span> \
            <span class="o">+</span> <span class="s2">&quot; is not within 1 and length of loaded spiketimes (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms_loaded</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;).&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms_loaded</span><span class="p">[</span><span class="n">i_trc</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spike_nrs</span><span class="p">[</span><span class="n">count</span><span class="p">]]),</span> \
            <span class="s2">&quot;spike index not found for trace &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;. length of spiketimes sublist for this trace = &quot;</span> \
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms_loaded</span><span class="p">[</span><span class="n">trc</span><span class="p">]))</span>
        <span class="c1"># convert indices from 1-based to 0-based</span>
        <span class="n">i_spikes_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spike_nrs</span><span class="p">[</span><span class="n">count</span><span class="p">]]</span>
        <span class="c1"># overwrite spiketimes_ms_modified, excluding those indexed to be removed</span>
        <span class="n">spiketimes_ms_modified</span><span class="p">[</span><span class="n">i_trc</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">spiketimes_ms_loaded</span><span class="p">[</span><span class="n">i_trc</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms_loaded</span><span class="p">[</span><span class="n">i_trc</span><span class="p">]))</span>
             <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">i_spikes_to_remove</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;removed &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spike_nrs</span><span class="p">[</span><span class="n">count</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot; spikes from trace number &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">trc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; in &quot;</span> <span class="o">+</span> <span class="n">filename_pkl</span><span class="p">)</span>

    <span class="c1"># overwrite pickle file with modified spiketimes</span>
    <span class="n">p_io</span><span class="o">.</span><span class="n">save_spiketimes_to_pkl</span><span class="p">(</span><span class="n">spiketimes_ms_modified</span><span class="p">,</span> <span class="n">filename_pkl</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spiketimes_ms_modified</span><span class="p">,</span> <span class="n">spiketimes_ms_loaded</span></div>


<div class="viewcode-block" id="get_psth"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_psth">[docs]</a><span class="k">def</span> <span class="nf">get_psth</span><span class="p">(</span><span class="n">spiketimes_ms</span><span class="p">,</span> <span class="n">duration_ms</span><span class="p">,</span> <span class="n">t_start_ms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">psth_dt_ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b_smoothed_psth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_filter_win_len</span><span class="o">=</span><span class="mi">9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate peri-stimulus time histogram from spiketimes over several aligned trials or neurons. Returns bin edges</span>
<span class="sd">    in milliseconds and average local spike rate in Hertz.</span>

<span class="sd">    :param spiketimes_ms: list of lists of spike times of the recorded neurons (one sublist per neuron or trial)</span>
<span class="sd">    :type spiketimes_ms: [[float]]</span>
<span class="sd">    :param duration_ms: total duration of recording / simulation and therefore of returned psth</span>
<span class="sd">    :type duration_ms: int or float</span>
<span class="sd">    :param t_start_ms: (optional) start time of recording / simulation and therefore of returned psth. default: 0</span>
<span class="sd">    :type t_start_ms: int or float</span>
<span class="sd">    :param psth_dt_ms: [default=5] time bin in milliseconds for the peri-stimulus-time histogram (psth)</span>
<span class="sd">    :type psth_dt_ms: int or float</span>
<span class="sd">    :param b_smoothed_psth: [default=True] also return smoothed psth (using Savitzky-Golay filter)</span>
<span class="sd">    :type b_smoothed_psth: bool</span>
<span class="sd">    :param smooth_filter_win_len: [default=9] length of window for Savitzky-Golay filter</span>
<span class="sd">    :type smooth_filter_win_len: int</span>
<span class="sd">    :return:</span>
<span class="sd">        - t_values: list of time values of psth bins (left edges) in milliseconds</span>
<span class="sd">        - psth: list of estimated local spike rates in Hertz per time bin</span>
<span class="sd">        - psth_smooth: same as psth, but smoothed using Savitzky-Golay filter</span>
<span class="sd">    :rtype:</span>
<span class="sd">        - t_values: [float]</span>
<span class="sd">        - psth: [float]</span>
<span class="sd">        - psth_smooth: [float]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate peri-stimulus-time histogram (psth)</span>
    <span class="n">bin_edges_left</span> <span class="o">=</span> <span class="n">p_util</span><span class="o">.</span><span class="n">integer_linspace</span><span class="p">(</span><span class="n">t_start_ms</span><span class="p">,</span> <span class="n">t_start_ms</span> <span class="o">+</span> <span class="n">duration_ms</span><span class="p">,</span> <span class="n">psth_dt_ms</span><span class="p">,</span> <span class="n">b_include_end</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">n_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges_left</span><span class="p">)</span>
    <span class="n">psth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bins</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index for psth throughout the loop</span>
    <span class="n">t_values</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># time values of bins (left value of each bin)</span>
    <span class="n">spiketimes_ms_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">spiketimes_ms</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">bin_edges_left</span><span class="p">:</span>
        <span class="n">n_spikes_in_bin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">spiketimes_ms_all</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">,</span> <span class="n">spiketimes_ms_all</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">+</span> <span class="n">psth_dt_ms</span><span class="p">))</span>
        <span class="n">psth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_spikes_in_bin</span> <span class="o">/</span> <span class="p">(</span><span class="n">psth_dt_ms</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms</span><span class="p">))</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="n">t_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">psth_dt_ms</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># get smoothed psth</span>
    <span class="k">if</span> <span class="n">b_smoothed_psth</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">spiketimes_ms_all</span><span class="p">):</span>
        <span class="n">psth_smooth</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">psth</span><span class="p">,</span> <span class="n">smooth_filter_win_len</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">b_smoothed_psth</span><span class="p">:</span>
            <span class="n">psth_smooth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psth_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">duration_ms</span> <span class="o">/</span> <span class="n">psth_dt_ms</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; get_psth(): no spiketimes found -&gt; psth_smooth set to all zeros&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">t_values</span><span class="p">,</span> <span class="n">psth</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">psth_smooth</span></div>


<div class="viewcode-block" id="sum_psths"><a class="viewcode-back" href="../p_analysis.html#p_analysis.sum_psths">[docs]</a><span class="k">def</span> <span class="nf">sum_psths</span><span class="p">(</span><span class="n">t_values</span><span class="p">,</span> <span class="n">psths</span><span class="p">,</span> <span class="n">offset_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b_smoothed_psth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_filter_win_len</span><span class="o">=</span><span class="mi">9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sums up multiple psths and returns the sum, as well as (optionally) a smoothed version. All input psths must have</span>
<span class="sd">    the same bin size and all offsets (if any) must be an integer multiple of the bin size. If the psths have different</span>
<span class="sd">    alignments, supplying a list of offset values (offset_ms) will shift the psths by this amount prior to summation.</span>

<span class="sd">    :param t_values: list of lists of time values in milliseconds of the psth bins (left side).</span>
<span class="sd">    :type t_values: [[int]] or [[float]]</span>
<span class="sd">    :param psths: list of lists of non-smoothed psth values (average spike rate as returned by p_analysis.get_psth())</span>
<span class="sd">    :type psths: [[float]]</span>
<span class="sd">    :param offset_ms: [default=None] list of time values at which to align each psth (0 will be at this timepoint)</span>
<span class="sd">    :type offset_ms: [int] or [float]</span>
<span class="sd">    :param b_smoothed_psth: [default=True] also return smoothed psth (using Savitzky-Golay filter)</span>
<span class="sd">    :type b_smoothed_psth: bool</span>
<span class="sd">    :param smooth_filter_win_len: [default=9] length of window for Savitzky-Golay filter</span>
<span class="sd">    :type smooth_filter_win_len: int</span>
<span class="sd">    :return:</span>
<span class="sd">        - t_val_for_all: list of time values in milliseconds of the psth bins of the summed psth (left side).</span>
<span class="sd">        - psth_summed: summed psth</span>
<span class="sd">        - psth_summed_smoothed: summed and smoothed psth</span>
<span class="sd">        - t_values_offset: t_values aligned to offset_ms</span>
<span class="sd">    :rtype:</span>
<span class="sd">        - t_val_for_all: [int] or [float]</span>
<span class="sd">        - psth_summed: [float]</span>
<span class="sd">        - psth_summed_smoothed: [float]</span>
<span class="sd">        - t_values_offset: [[int]] or [[float]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">if</span> <span class="n">offset_ms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_values</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">psths</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_ms</span><span class="p">),</span> \
            <span class="s2">&quot;t_values, psths and offset_ms must all have the same number of elements&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_values</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">psths</span><span class="p">),</span> <span class="s2">&quot;t_values and psths must have the same number of elements&quot;</span>

    <span class="c1"># align timepoints to offset</span>
    <span class="n">t_values_offset</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">offset_ms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_values</span><span class="p">)):</span>
            <span class="n">t_values_offset</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t_values</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset_ms</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_values</span><span class="p">[</span><span class="n">n</span><span class="p">]))])</span>

    <span class="c1"># if a single psth was given, just return these values, after offsetting the t_values</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">psths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">psth_smoothed</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">psths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">smooth_filter_win_len</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t_values_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psth_smoothed</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">t_values_offset</span>

    <span class="c1"># get intersection of bin edge time values of all psths</span>
    <span class="n">t_val_for_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">t_values_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_values_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p_util</span><span class="o">.</span><span class="n">integer_linspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_values_offset</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b_include_end</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">t_val_for_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">t_val_for_all</span><span class="p">,</span> <span class="n">t_values_offset</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># sum psth values at those time points</span>
    <span class="n">psth_summed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_val_for_all</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_val_for_all</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_values_offset</span><span class="p">)):</span>
            <span class="n">idx_t_cur</span> <span class="o">=</span> <span class="n">t_values_offset</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t_val_for_all</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
            <span class="n">psth_summed</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">psth_summed</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">psths</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">idx_t_cur</span><span class="p">]</span>

    <span class="c1"># get smoothed psth</span>
    <span class="k">if</span> <span class="n">b_smoothed_psth</span><span class="p">:</span>
        <span class="n">psth_summed_smoothed</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">psth_summed</span><span class="p">,</span> <span class="n">smooth_filter_win_len</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">psth_summed_smoothed</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">t_val_for_all</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">psth_summed</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">psth_summed_smoothed</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">t_values_offset</span></div>


<div class="viewcode-block" id="subthreshold_wiggliness"><a class="viewcode-back" href="../p_analysis.html#p_analysis.subthreshold_wiggliness">[docs]</a><span class="k">def</span> <span class="nf">subthreshold_wiggliness</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">spikemon</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the standard deviation of the membrane potential derivative of a neuron over a given timespan.</span>

<span class="sd">    :param statemon: brian2 StateMonitor - like(!) SimpleNamespace from file or dict from b2...get_states()</span>
<span class="sd">    :type statemon: SimpleNamespace or dict</span>
<span class="sd">    :param spikemon: brian2 SpikeMonitor - like(!) SimpleNamespace from file or dict from b2...get_states()</span>
<span class="sd">    :type spikemon: SimpleNamespace or dict</span>
<span class="sd">    :param info: dictionary containing additional information about simulation</span>
<span class="sd">    :type info: dict</span>
<span class="sd">    :param idx_nrn_abs: index of neuron to be analyzed within statemon</span>
<span class="sd">    :type idx_nrn_abs: int</span>
<span class="sd">    :param t_start: beginning of timespan to be analyzed in milliseconds</span>
<span class="sd">    :type t_start: int or float</span>
<span class="sd">    :param t_end: end of timespan to be analyzed in milliseconds</span>
<span class="sd">    :type t_end: int or float</span>
<span class="sd">    :return: std_diff_v: standard deviation of membrane potential derivative</span>
<span class="sd">    :rtype: std_diff_v: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">statemonitor</span><span class="o">.</span><span class="n">StateMonitor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">SimpleNamespace</span><span class="p">),</span> \
        <span class="s2">&quot;statemon must be a b2.StateMonitor or (if loaded through p_io.load_monitors) SimpleNamespace object&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spikemon</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">statemonitor</span><span class="o">.</span><span class="n">StateMonitor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spikemon</span><span class="p">,</span> <span class="n">SimpleNamespace</span><span class="p">),</span> \
        <span class="s2">&quot;spikemon must be a b2.StateMonitor or (if loaded through p_io.load_monitors) SimpleNamespace object&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> \
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_end</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_end</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t_start</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end</span> <span class="o">&gt;</span> <span class="n">t_start</span><span class="p">,</span> \
        <span class="s2">&quot;t_start and t_end must be positive integers or floats with t_end &gt; t_start&quot;</span>

    <span class="c1"># if there is no t_end, return nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">t_end</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># if neuron_index is a negative number (i.e. counting from end), translate that to a positive index</span>
    <span class="k">if</span> <span class="n">idx_nrn_abs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">idx_nrn_abs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;population_sizes&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">idx_nrn_abs</span>

    <span class="c1"># get indices to t_start and t_end</span>
    <span class="n">idx_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">t</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">t</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t_end</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># get membrane potential derivative and number of spikes between t_start and t_end</span>
    <span class="n">diff_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span><span class="p">)</span>
    <span class="n">i_spiketimes_nrn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spikemon</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">idx_nrn_abs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i_spiketimes_nrn</span><span class="p">):</span>
        <span class="n">n_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">t_start</span> <span class="o">&lt;</span> <span class="n">spikemon</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">i_spiketimes_nrn</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span>
                                         <span class="n">spikemon</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">i_spiketimes_nrn</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&lt;</span> <span class="n">t_end</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_spikes</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># sort derivative values and remove smallest n (largest negative slope), where n is number of spikes</span>
    <span class="c1"># (removing large slopes due to LIF reset)</span>
    <span class="n">diff_v_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">diff_v</span><span class="p">)[</span><span class="nb">range</span><span class="p">(</span><span class="n">n_spikes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_v</span><span class="p">))]</span>

    <span class="c1"># get standard deviation of membrane potential derivative (after spikes removed)</span>
    <span class="n">std_diff_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff_v_cut</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">std_diff_v</span></div>


<div class="viewcode-block" id="get_average_potential"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_average_potential">[docs]</a><span class="k">def</span> <span class="nf">get_average_potential</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the average membrane potential of a neuron over a given timespan.</span>

<span class="sd">    :param statemon: brian2 StateMonitor or -like(!) SimpleNamespace from file</span>
<span class="sd">    :type statemon: SimpleNamespace or b2.monitors.statemonitor.StateMonitor</span>
<span class="sd">    :param info: dictionary containing additional information about simulation</span>
<span class="sd">    :type info: dict</span>
<span class="sd">    :param idx_nrn_abs: index of neuron to be analyzed within statemon</span>
<span class="sd">    :type idx_nrn_abs: int</span>
<span class="sd">    :param t_start: beginning of timespan to be analyzed in milliseconds</span>
<span class="sd">    :type t_start: int or float</span>
<span class="sd">    :param t_end: end of timespan to be analyzed in milliseconds</span>
<span class="sd">    :type t_end: int or float</span>
<span class="sd">    :return: avg_v: average of membrane potential</span>
<span class="sd">    :rtype: avg_v: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">statemonitor</span><span class="o">.</span><span class="n">StateMonitor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">SimpleNamespace</span><span class="p">),</span> \
        <span class="s2">&quot;statemon must be a b2.StateMonitor or (if loaded through p_io.load_monitors) SimpleNamespace object&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> \
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_end</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_end</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t_start</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end</span> <span class="o">&gt;</span> <span class="n">t_start</span><span class="p">,</span> \
        <span class="s2">&quot;t_start and t_end must be positive integers or floats with t_end &gt; t_start&quot;</span>

    <span class="c1"># if there is no t_end, return nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">t_end</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># if neuron_index is a negative number (i.e. counting from end), translate that to a positive index</span>
    <span class="k">if</span> <span class="n">idx_nrn_abs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">idx_nrn_abs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;population_sizes&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">idx_nrn_abs</span>

    <span class="c1"># get indices to t_start and t_end</span>
    <span class="n">idx_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">t</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">t</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t_end</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># get average membrane potential between t_start and t_end</span>
    <span class="n">avg_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">avg_v</span></div>


<div class="viewcode-block" id="get_stdev_potential"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_stdev_potential">[docs]</a><span class="k">def</span> <span class="nf">get_stdev_potential</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the standard deviation of the membrane potential of a neuron over a given timespan.</span>

<span class="sd">    :param statemon: brian2 StateMonitor or -like(!) SimpleNamespace from file</span>
<span class="sd">    :type statemon: SimpleNamespace or b2.monitors.statemonitor.StateMonitor</span>
<span class="sd">    :param info: dictionary containing additional information about simulation</span>
<span class="sd">    :type info: dict</span>
<span class="sd">    :param idx_nrn_abs: index of neuron to be analyzed within statemon</span>
<span class="sd">    :type idx_nrn_abs: int</span>
<span class="sd">    :param t_start: beginning of timespan to be analyzed in milliseconds</span>
<span class="sd">    :type t_start: int or float</span>
<span class="sd">    :param t_end: end of timespan to be analyzed in milliseconds</span>
<span class="sd">    :type t_end: int or float</span>
<span class="sd">    :return: stdev_v: standard deviation of membrane potential</span>
<span class="sd">    :rtype: stdev_v: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">monitors</span><span class="o">.</span><span class="n">statemonitor</span><span class="o">.</span><span class="n">StateMonitor</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">statemon</span><span class="p">,</span> <span class="n">SimpleNamespace</span><span class="p">),</span> \
        <span class="s2">&quot;statemon must be a b2.StateMonitor or (if loaded through p_io.load_monitors) SimpleNamespace object&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> \
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_end</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_end</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t_start</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end</span> <span class="o">&gt;</span> <span class="n">t_start</span><span class="p">,</span> \
        <span class="s2">&quot;t_start and t_end must be positive integers or floats with t_end &gt; t_start&quot;</span>

    <span class="c1"># if there is no t_end, return nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">t_end</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># if neuron_index is a negative number (i.e. counting from end), translate that to a positive index</span>
    <span class="k">if</span> <span class="n">idx_nrn_abs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">idx_nrn_abs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;population_sizes&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">idx_nrn_abs</span>

    <span class="c1"># get indices to t_start and t_end</span>
    <span class="n">idx_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">t</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t_start</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">t</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t_end</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># get average membrane potential between t_start and t_end</span>
    <span class="n">stdev_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">statemon</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">idx_start</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stdev_v</span></div>


<div class="viewcode-block" id="get_t_first_spike_mod"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_t_first_spike_mod">[docs]</a><span class="k">def</span> <span class="nf">get_t_first_spike_mod</span><span class="p">(</span><span class="n">spikemons</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">search_from_ms</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the timepoint in the simulation when neuron idx_nrn_abs fired its first spike.</span>

<span class="sd">    :param spikemons: (list of) brian2 SpikeMonitor - like(!) SimpleNamespaces from file or dicts from b2...get_states()</span>
<span class="sd">    :type spikemons: SimpleNamespace or dict or list</span>
<span class="sd">    :param info: dictionary or list of dicts containing additional information about simulation (one dict per run)</span>
<span class="sd">    :type info: dict or list</span>
<span class="sd">    :param idx_nrn_abs: absolute index to the neuron</span>
<span class="sd">    :type idx_nrn_abs: int</span>
<span class="sd">    :param search_from_ms: if greater than 0, look for the first spike after this time in milliseconds</span>
<span class="sd">    :type search_from_ms: int or float</span>
<span class="sd">    :return: spike_time: list of times of first spike of neuron given by idx_nrn_abs. One entry per monitor (run)</span>
<span class="sd">    :rtype: spike_time: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if spikemons and info contain a single entry, convert them to a list</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spikemons</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">spikemons</span> <span class="o">=</span> <span class="p">[</span><span class="n">spikemons</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="n">info</span><span class="p">]</span>

    <span class="c1"># if idx_nrn_abs is a negative number, translate that to a positive index</span>
    <span class="k">if</span> <span class="n">idx_nrn_abs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">idx_nrn_abs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;population_sizes&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">idx_nrn_abs</span>

    <span class="n">spike_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spikemons</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">mon</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spikemons</span><span class="p">)):</span>
        <span class="c1"># get time of first spike</span>
        <span class="k">if</span> <span class="n">search_from_ms</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx_all_spikes_nrn_oi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spikemons</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">idx_nrn_abs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx_spikes_after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spikemons</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">idx_all_spikes_nrn_oi</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;</span> <span class="n">search_from_ms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx_spikes</span> <span class="o">=</span> <span class="n">idx_all_spikes_nrn_oi</span><span class="p">[</span><span class="n">idx_spikes_after</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spikemons</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">idx_nrn_abs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># convert values back to milliseconds</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">spikemons</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">idx_spikes</span><span class="p">]):</span>
            <span class="n">spike_time</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span> <span class="o">=</span> <span class="n">spikemons</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">idx_spikes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>
    <span class="c1"># set values NaN where no spike occured</span>
    <span class="n">spike_time</span><span class="p">[</span><span class="n">spike_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">spike_time</span></div>


<div class="viewcode-block" id="get_psp_count"><a class="viewcode-back" href="../p_analysis.html#p_analysis.get_psp_count">[docs]</a><span class="k">def</span> <span class="nf">get_psp_count</span><span class="p">(</span><span class="n">spikemon</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">idx_nrn_abs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the number of excitatory and inhibitory post-synaptic potentials (i.e. presynaptic spikes separated by</span>
<span class="sd">    positive/negative synaptic weights) of a neuron (idx_nrn_abs).</span>

<span class="sd">    :param spikemon: brian2 SpikeMonitor - like(!) SimpleNamespace from file</span>
<span class="sd">    :type spikemon: SimpleNamespace</span>
<span class="sd">    :param connectivity: dictionary containing synaptic connectivity information</span>
<span class="sd">    :type connectivity: dict</span>
<span class="sd">    :param info: dictionary containing additional information about simulation</span>
<span class="sd">    :type info: dict</span>
<span class="sd">    :param idx_nrn_abs: index of neuron to be analyzed within statemon</span>
<span class="sd">    :type idx_nrn_abs: int</span>
<span class="sd">    :return:    - n_epsp: number of excitatory post synaptic potentials, i.e. presynaptic spikes in synapse groups that</span>
<span class="sd">                    have positive weights.</span>
<span class="sd">                - n_ipsp: number of inhibitory post synaptic potentials, i.e. presynaptic spikes in synapse groups that</span>
<span class="sd">                    have negative weights.</span>
<span class="sd">    :rtype:     - n_epsp: int</span>
<span class="sd">                - n_ipsp: int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get relative idx and population idx of neuron of interest</span>
    <span class="n">idx_nrn_rel</span><span class="p">,</span> <span class="n">idx_pop_oi</span> <span class="o">=</span> <span class="n">p_util</span><span class="o">.</span><span class="n">get_rel_from_abs_nrn_idx</span><span class="p">(</span><span class="n">idx_nrn_abs</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;population_sizes&#39;</span><span class="p">])</span>

    <span class="c1"># loop through synapse groups and get the number of spikes of all presynaptic neurons if pop_oi is post</span>
    <span class="n">n_ipsp</span> <span class="o">=</span> <span class="n">n_epsp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;syn_post_idx&#39;</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;syn_post_idx&#39;</span><span class="p">][</span><span class="n">syn</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx_pop_oi</span><span class="p">:</span>
            <span class="n">idx_nrn_pre_rel</span> <span class="o">=</span> <span class="n">connectivity</span><span class="p">[</span><span class="n">syn</span><span class="p">][</span><span class="s1">&#39;i&#39;</span><span class="p">][</span><span class="n">connectivity</span><span class="p">[</span><span class="n">syn</span><span class="p">][</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx_nrn_rel</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;syn_weight&#39;</span><span class="p">][</span><span class="n">syn</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_spikes_per_idx_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spikemon</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>
                <span class="n">n_epsp</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_spikes_per_idx_all</span><span class="p">[</span><span class="n">idx_nrn_pre_rel</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;syn_weight&#39;</span><span class="p">][</span><span class="n">syn</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_spikes_per_idx_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">spikemon</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>
                <span class="n">n_ipsp</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n_spikes_per_idx_all</span><span class="p">[</span><span class="n">idx_nrn_pre_rel</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_epsp</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_ipsp</span><span class="p">)</span></div>


<div class="viewcode-block" id="prespike_trace_average"><a class="viewcode-back" href="../p_analysis.html#p_analysis.prespike_trace_average">[docs]</a><span class="k">def</span> <span class="nf">prespike_trace_average</span><span class="p">(</span><span class="n">traces</span><span class="p">,</span> <span class="n">spiketimes_ms</span><span class="p">,</span> <span class="n">sampling_frequency_khz</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">smooth_filter_win_len</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
                           <span class="n">b_normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">b_spiketime_is_onset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">b_smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the average membrane potential of all smoothed traces of a neuron over the timecourse from duration</span>
<span class="sd">    before and up to the first spike onset in the the trace. Returns all smoothed time series (len=duration) and average</span>

<span class="sd">    :param traces: (list of) numpy ndarray(s) of voltage traces</span>
<span class="sd">    :type traces: np.ndarray or list</span>
<span class="sd">    :param spiketimes_ms: list of lists of spike times of the neuron (one sublist per trial, i.e. array in traces)</span>
<span class="sd">    :type spiketimes_ms: [[float]]</span>
<span class="sd">    :param sampling_frequency_khz: [default=40] sampling frequency of traces in kHz</span>
<span class="sd">    :type sampling_frequency_khz: int or float</span>
<span class="sd">    :param duration: [default=100] duration of the returned time series relative to the first spike in each trace,</span>
<span class="sd">        in ms. negative value: timespan after spike.</span>
<span class="sd">    :type duration: int or float</span>
<span class="sd">    :param smooth_filter_win_len: [default=11] length of window for Savitzky-Golay filter</span>
<span class="sd">    :type smooth_filter_win_len: int</span>
<span class="sd">    :param b_normalize: if True,, normalize returned timesieries so that final value (spike onset) is 0 mV</span>
<span class="sd">    :type b_normalize: bool or int</span>
<span class="sd">    :param b_spiketime_is_onset: if True, spiketimes_ms is considered onset of spike (e.g. LIF model neurons)</span>
<span class="sd">    :type b_spiketime_is_onset: bool or int</span>
<span class="sd">    :param b_smooth: if True, smooth traces first</span>
<span class="sd">    :type b_smooth: bool or int</span>
<span class="sd">    :return: - timeseries_average: average time series of all traces that contain a spike and in which the time series</span>
<span class="sd">                before/after the first spike fully lies within the duration of the trace</span>
<span class="sd">             - all_timeseries: list containing all timeseries that were included in the average (i.e. section of trace</span>
<span class="sd">                of length duration before/after the first spike in each trace)</span>
<span class="sd">             - n_traces_included: number of traces that were included in the average (i.e. that fit the above criteria)</span>
<span class="sd">    :rtype:  - timeseries_average: numpy.ndarray</span>
<span class="sd">             - all_timeseries: list</span>
<span class="sd">             - n_traces_included: int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">traces</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">spiketimes_ms</span><span class="p">),</span> <span class="s2">&quot;arguments traces and spiketimes_ms must have the same number of &quot;</span> \
                                              <span class="s2">&quot;elements (sublists/arrays)&quot;</span>

    <span class="c1"># smooth traces using savitzky-golay filter (from scipy.signal)</span>
    <span class="n">traces_smooth_sg</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">b_smooth</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">trc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traces</span><span class="p">)):</span>
            <span class="n">traces_smooth_sg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="n">trc</span><span class="p">],</span> <span class="n">smooth_filter_win_len</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">traces_smooth_sg</span> <span class="o">=</span> <span class="n">traces</span>

    <span class="c1"># loop through sublists of spiketimes_ms and collect time series of length duration before/after first spike from</span>
    <span class="c1"># each trace, if the trace contains a spike and the time series fully lies within the trace</span>
    <span class="n">all_timeseries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_traces_included</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i_cur_trace</span><span class="p">,</span> <span class="n">spiketimes_cur_trace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spiketimes_ms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spiketimes_cur_trace</span><span class="p">:</span>
            <span class="n">t_first_spike</span> <span class="o">=</span> <span class="n">spiketimes_cur_trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">b_spiketime_is_onset</span><span class="p">:</span>
                <span class="n">t_spike_onset</span> <span class="o">=</span> <span class="n">t_first_spike</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_spike_onset</span><span class="p">,</span> <span class="n">spike_threshold</span> <span class="o">=</span> <span class="n">get_onset_of_spikes</span><span class="p">(</span><span class="n">traces</span><span class="p">[</span><span class="n">i_cur_trace</span><span class="p">],</span> <span class="p">[[</span><span class="n">t_first_spike</span><span class="p">]],</span>
                                                                     <span class="n">sampling_frequency_khz</span><span class="o">=</span><span class="n">sampling_frequency_khz</span><span class="p">)</span>
                <span class="n">t_spike_onset</span> <span class="o">=</span> <span class="n">t_spike_onset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">spike_threshold</span> <span class="o">=</span> <span class="n">spike_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">samp_spike_onset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">t_spike_onset</span> <span class="o">*</span> <span class="n">sampling_frequency_khz</span><span class="p">))</span>
            <span class="n">t_start_or_end</span> <span class="o">=</span> <span class="n">t_spike_onset</span> <span class="o">-</span> <span class="n">duration</span>
            <span class="n">samp_start_or_end</span> <span class="o">=</span> <span class="n">samp_spike_onset</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">duration</span> <span class="o">*</span> <span class="n">sampling_frequency_khz</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">t_start_or_end</span> <span class="o">&lt;</span> <span class="n">t_spike_onset</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">samp_start_or_end</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b_normalize</span><span class="p">:</span>
                        <span class="n">all_timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">i_cur_trace</span><span class="p">][</span><span class="n">samp_start_or_end</span><span class="p">:</span><span class="n">samp_spike_onset</span><span class="p">]</span> <span class="o">-</span>
                                              <span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">i_cur_trace</span><span class="p">][</span><span class="n">samp_spike_onset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">all_timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">i_cur_trace</span><span class="p">][</span><span class="n">samp_start_or_end</span><span class="p">:</span><span class="n">samp_spike_onset</span><span class="p">])</span>
                    <span class="n">n_traces_included</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;! Trace &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_cur_trace</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; skipped, because first spike is less than time series &quot;</span> <span class="o">+</span>
                          <span class="s2">&quot;duration (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ms) into the recording...&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">t_start_or_end</span> <span class="o">&gt;</span> <span class="n">t_spike_onset</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">samp_start_or_end</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">b_normalize</span><span class="p">:</span>
                        <span class="n">all_timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">i_cur_trace</span><span class="p">][</span><span class="n">samp_spike_onset</span><span class="p">:</span><span class="n">samp_start_or_end</span><span class="p">]</span> <span class="o">-</span>
                                              <span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">i_cur_trace</span><span class="p">][</span><span class="n">samp_spike_onset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">all_timeseries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traces_smooth_sg</span><span class="p">[</span><span class="n">i_cur_trace</span><span class="p">][</span><span class="n">samp_spike_onset</span><span class="p">:</span><span class="n">samp_start_or_end</span><span class="p">])</span>
                    <span class="n">n_traces_included</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;! Trace &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_cur_trace</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; skipped, because first spike is less than time series &quot;</span> <span class="o">+</span>
                          <span class="s2">&quot;duration (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ms) from the end of the recording...&quot;</span><span class="p">)</span>

    <span class="c1"># calculate the average of all time series</span>
    <span class="n">timeseries_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_timeseries</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">timeseries_average</span><span class="p">,</span> <span class="n">all_timeseries</span><span class="p">,</span> <span class="n">n_traces_included</span></div>


<div class="viewcode-block" id="check_conditions"><a class="viewcode-back" href="../p_analysis.html#p_analysis.check_conditions">[docs]</a><span class="k">def</span> <span class="nf">check_conditions</span><span class="p">(</span><span class="n">spikemons</span><span class="p">,</span> <span class="n">statemons</span><span class="p">,</span> <span class="n">infos</span><span class="p">,</span> <span class="n">config_lo</span><span class="p">,</span> <span class="n">n_param_vals_x</span><span class="p">,</span> <span class="n">n_param_vals_y</span><span class="p">,</span>
                     <span class="n">baseline_cond</span><span class="p">,</span> <span class="n">n_spikes_cond</span><span class="p">,</span> <span class="n">t_baseline</span><span class="p">,</span> <span class="n">t_spikes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if the baseline membrane potential of the neuron of interest (defined in config_lo[&#39;plot&#39;]</span>
<span class="sd">    [&#39;idx_nrn_oi_relative&#39;]) from a parameter exploration with two free parameters (or one parameter for two synapses/</span>
<span class="sd">    populations) is within a certain range, and if it fired a certain number of spikes within a certain timespan.</span>

<span class="sd">    :param spikemons: list of dict(s) containing SpikeMonitor data from b2...get_states()</span>
<span class="sd">    :type spikemons: list</span>
<span class="sd">    :param statemons: list of dict(s) containing StateMonitor data from b2...get_states()</span>
<span class="sd">    :type statemons: list</span>
<span class="sd">    :param infos: list of dict(s) containing additional information about simulation (as created by run_simulation())</span>
<span class="sd">    :type infos: list</span>
<span class="sd">    :param config_lo: config dict as loaded from .json file (output directory), contains lower limits of all params</span>
<span class="sd">    :type config_lo: dict</span>
<span class="sd">    :param n_param_vals_x: number of values for first free parameter</span>
<span class="sd">    :type n_param_vals_x: int</span>
<span class="sd">    :param n_param_vals_y: number of values for first free parameter</span>
<span class="sd">    :type n_param_vals_y: int</span>
<span class="sd">    :param baseline_cond: condition for baseline membrane potential. tuple of lower and upper limit for condition to</span>
<span class="sd">        be considered met.</span>
<span class="sd">    :type baseline_cond: tuple or list</span>
<span class="sd">    :param n_spikes_cond: condition for number of spikes. tuple of lower and upper limit for condition to</span>
<span class="sd">        be considered met.</span>
<span class="sd">    :type n_spikes_cond: tuple or list</span>
<span class="sd">    :param t_baseline: time window in which the baseline membrane potential condition was checked (start, end)</span>
<span class="sd">    :type t_baseline: tuple or list</span>
<span class="sd">    :param t_spikes: time window in which the number of spikes condition was checked (start, end)</span>
<span class="sd">    :type t_spikes: tuple or list</span>
<span class="sd">    :return:  conditions_met: numpy array of dimension c*x*y, where c is the number of conditions checked and x/y is a</span>
<span class="sd">        2d matrix of the space of the two varied parameters, in which 1=condition met, 0=not met.</span>
<span class="sd">    :rtype:   conditions_met: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># constants</span>
    <span class="n">n_conditions</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># set conditions</span>
    <span class="n">conditions_met_linear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_conditions</span><span class="p">,</span> <span class="n">n_param_vals_x</span> <span class="o">*</span> <span class="n">n_param_vals_y</span><span class="p">))</span>
    <span class="n">t1_baseline</span> <span class="o">=</span> <span class="n">t_baseline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>
    <span class="n">t2_baseline</span> <span class="o">=</span> <span class="n">t_baseline</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>
    <span class="n">t1_spikes</span> <span class="o">=</span> <span class="n">t_spikes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>
    <span class="n">t2_spikes</span> <span class="o">=</span> <span class="n">t_spikes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>
    <span class="n">min_v_baseline</span> <span class="o">=</span> <span class="n">baseline_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span>
    <span class="n">max_v_baseline</span> <span class="o">=</span> <span class="n">baseline_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span>
    <span class="n">min_n_spikes</span> <span class="o">=</span> <span class="n">n_spikes_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_n_spikes</span> <span class="o">=</span> <span class="n">n_spikes_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># check for conditions met and add a 1 to the output arrays</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spikemons</span><span class="p">)):</span>
        <span class="c1"># get neuron of interest from config</span>
        <span class="n">nrn_oi_abs</span> <span class="o">=</span> <span class="n">p_util</span><span class="o">.</span><span class="n">get_abs_from_rel_nrn_idx</span><span class="p">(</span><span class="n">config_lo</span><span class="p">[</span><span class="s1">&#39;plot&#39;</span><span class="p">][</span><span class="s1">&#39;idx_nrn_oi_relative&#39;</span><span class="p">],</span>
                                                     <span class="n">config_lo</span><span class="p">[</span><span class="s1">&#39;plot&#39;</span><span class="p">][</span><span class="s1">&#39;idx_pop_oi&#39;</span><span class="p">],</span>
                                                     <span class="n">infos</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="s1">&#39;population_sizes&#39;</span><span class="p">])</span>
        <span class="n">b_spike_from_nrn_oi</span> <span class="o">=</span> <span class="n">spikemons</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">i</span> <span class="o">==</span> <span class="n">nrn_oi_abs</span>
        <span class="n">t_spike_from_nrn_oi</span> <span class="o">=</span> <span class="n">spikemons</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">b_spike_from_nrn_oi</span><span class="p">]</span>
        <span class="n">n_spikes_in_win</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">t1_spikes</span> <span class="o">&lt;=</span> <span class="n">t_spike_from_nrn_oi</span><span class="p">,</span> <span class="n">t_spike_from_nrn_oi</span> <span class="o">&lt;=</span> <span class="n">t2_spikes</span><span class="p">))</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemons</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">t1_baseline</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemons</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">t2_baseline</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">baseline_pm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">statemons</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">nrn_oi_abs</span><span class="p">,</span> <span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">min_n_spikes</span> <span class="o">&lt;=</span> <span class="n">n_spikes_in_win</span> <span class="o">&lt;=</span> <span class="n">max_n_spikes</span><span class="p">:</span>
            <span class="n">conditions_met_linear</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">min_v_baseline</span> <span class="o">&lt;=</span> <span class="n">baseline_pm</span> <span class="o">&lt;=</span> <span class="n">max_v_baseline</span><span class="p">:</span>
            <span class="n">conditions_met_linear</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">conditions_met</span> <span class="o">=</span> <span class="n">conditions_met_linear</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_conditions</span><span class="p">,</span> <span class="n">n_param_vals_y</span><span class="p">,</span> <span class="n">n_param_vals_x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">conditions_met</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Philipp Norton.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>