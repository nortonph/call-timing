

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lif &mdash; call-time-model  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/p_theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> call-time-model
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../config_files.html">Config Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">call-time-model</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>lif</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for lif</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Main function for running simulations of spiking network models using brian2, based on equations and parameters</span>
<span class="sd">pulled from .json config files. Main function: run_simulation(). [call-time-model]</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Philipp Norton, 2019-2021</span>

<span class="c1"># import libraries</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">brian2</span> <span class="k">as</span> <span class="nn">b2</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>

<span class="c1"># import my functions</span>
<span class="kn">from</span> <span class="nn">fcn</span> <span class="kn">import</span> <span class="n">p_input</span><span class="p">,</span> <span class="n">p_io</span><span class="p">,</span> <span class="n">p_util</span>

<span class="c1"># constant &quot;global&quot; variables</span>
<span class="n">STANDALONE_CODE_GEN</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># The store/restore mechanism is not supported in the C++ standalone!</span>


<div class="viewcode-block" id="run_simulation"><a class="viewcode-back" href="../lif.html#lif.run_simulation">[docs]</a><span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">config_preloaded</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run_id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clock_dt_ms</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
                   <span class="n">input_spiketimes_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename_out_arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recorded_variables</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">recording_start_ms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">b_always_save_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">b_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run a simulation using this model with the parameters supplied by a .json config file.</span>

<span class="sd">    :param model_name: filename of parameter config file (ending .json can be omitted from string)</span>
<span class="sd">    :type model_name: str</span>
<span class="sd">    :param config_preloaded: if a config dictionary is supplied here, this will be used to run the simulation, instead</span>
<span class="sd">        of loading a config from the .json file indicated by model_name</span>
<span class="sd">    :type config_preloaded: None or dict</span>
<span class="sd">    :param log_name: [default=None] name of logger object (standard python logging). if None, a logger will be created</span>
<span class="sd">        for console output only</span>
<span class="sd">    :type log_name: str or None</span>
<span class="sd">    :param run_id: [default=0] integer id used to identify this run with corresponding log files</span>
<span class="sd">    :type run_id: int</span>
<span class="sd">    :param sim_time_ms: [default=None] duration of simulation in milliseconds. if None: load from config file</span>
<span class="sd">    :type sim_time_ms: int or None</span>
<span class="sd">    :param clock_dt_ms: [default=0.02] simulation time step in milliseconds, between 0 and (including) 1</span>
<span class="sd">    :type clock_dt_ms: float</span>
<span class="sd">    :param input_spiketimes_ms: [default=None] list of list(s) of list(s) of spiketimes to be used as input onto model</span>
<span class="sd">        neurons using SpikeGeneratorGroups. Each sublist corresponds to a population that acts as input on the</span>
<span class="sd">        respective model neuron population if n_generators == n_populations. If n_generators &gt; 1 and n_populations == 1,</span>
<span class="sd">        then all generators connect to the population. Each subsublist contains all spiketimes of one generator neuron.</span>
<span class="sd">        Condition for connections from generators to neurons can be set in config[&#39;generator&#39;][&#39;condition&#39;]</span>
<span class="sd">    :type input_spiketimes_ms: [[[float]]] or None</span>
<span class="sd">    :param filename_out_arg: [default=None] optional filename for output .pkl file. if None, this is handled by</span>
<span class="sd">        p_io.load_config()</span>
<span class="sd">    :type filename_out_arg: None or str</span>
<span class="sd">    :param recorded_variables: (tuple of) name(s) of the variable(s) to be recorded in StateMonitor and saved to .pkl</span>
<span class="sd">    :type recorded_variables: str or tuple</span>
<span class="sd">    :param recording_start_ms: [default=0] start recording spikes and states at this timepoint into the simulation</span>
<span class="sd">    :type recording_start_ms: float or int</span>
<span class="sd">    :param b_always_save_output: if False, run is_worth_saving to check a certain condition for saving output to .pkl</span>
<span class="sd">    :type b_always_save_output: bool</span>
<span class="sd">    :param b_verbose: [default=False] if True, additional information is output during the run</span>
<span class="sd">    :type b_verbose: bool or int</span>
<span class="sd">    :return:  - filename_out: filename for output .pkl file</span>
<span class="sd">              - conditions_not_met: list of indices of conditions not met (if any)</span>
<span class="sd">    :rtype:   - filename_out: str</span>
<span class="sd">              - conditions_not_met: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># enable standalone code generation (see brian2 doc: computational methods &amp; efficiency)</span>
    <span class="k">if</span> <span class="n">STANDALONE_CODE_GEN</span><span class="p">:</span>
        <span class="n">b2</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="s1">&#39;cpp_standalone&#39;</span><span class="p">)</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;argument &#39;model_name&#39; must be a string&quot;</span>
    <span class="k">assert</span> <span class="n">config_preloaded</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config_preloaded</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> \
        <span class="s2">&quot;argument &#39;config_preloaded&#39; must be either None or dictionary (same format as if loaded from config .json)&quot;</span>
    <span class="k">assert</span> <span class="n">sim_time_ms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sim_time_ms</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sim_time_ms</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> \
        <span class="s2">&quot;argument &#39;sim_time_ms&#39; must be an integer &gt;= 0 or None&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clock_dt_ms</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">clock_dt_ms</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> \
        <span class="s2">&quot;argument &#39;clock_dt_ms&#39; must be a float &gt; 0 and &lt;= 1&quot;</span>
    <span class="k">assert</span> <span class="n">log_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> \
        <span class="s2">&quot;argument &#39;log_name&#39; must be either None or string (name of logging.Logger instance)&quot;</span>
    <span class="k">assert</span> <span class="n">filename_out_arg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename_out_arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> \
        <span class="s2">&quot;argument &#39;filename_out_arg&#39; must be either None or string (filename of output .pkl file)&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">run_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;argument run_id must be an integer&quot;</span>

    <span class="c1"># if no logger name was passed, create one for console output, otherwise get the one identified by the passed name</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">log_name</span><span class="p">:</span>
        <span class="n">log_name</span> <span class="o">=</span> <span class="s1">&#39;default_console&#39;</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">log_name</span><span class="p">)</span>
        <span class="n">console_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
        <span class="n">console_handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">console_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">console_handler</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">log_name</span><span class="p">)</span>

    <span class="c1"># load model config file (.json), or use passed config</span>
    <span class="k">if</span> <span class="n">config_preloaded</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">filename_out_arg</span><span class="p">,</span> <span class="s1">&#39;if preloaded config is passed, filename_out_arg must be passed as well&#39;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config_preloaded</span>
        <span class="n">filename_cfg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">filename_out</span> <span class="o">=</span> <span class="n">filename_out_arg</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preloaded config used. filename_out: &quot;</span> <span class="o">+</span> <span class="n">filename_out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">config</span><span class="p">,</span> <span class="n">filename_cfg</span><span class="p">,</span> <span class="n">filename_out</span> <span class="o">=</span> <span class="n">p_io</span><span class="o">.</span><span class="n">load_config</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Config file &#39;&quot;</span> <span class="o">+</span> <span class="n">filename_cfg</span> <span class="o">+</span> <span class="s2">&quot;&#39; loaded.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename_out_arg</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;o default filename_out is overwritten from &quot;</span> <span class="o">+</span> <span class="n">filename_out</span> <span class="o">+</span> <span class="s2">&quot; to &quot;</span> <span class="o">+</span> <span class="n">filename_out_arg</span><span class="p">)</span>
            <span class="n">filename_out</span> <span class="o">=</span> <span class="n">filename_out_arg</span>

    <span class="c1"># get seed for random number generator. load from config if present. if single value, duplicate for noise and conn</span>
    <span class="k">if</span> <span class="s1">&#39;rng_seed&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;rng_seed&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;rng_seed&#39;</span><span class="p">],</span> <span class="nb">int</span><span class="p">),</span> \
            <span class="s2">&quot;config[&#39;misc&#39;][&#39;rng_seed&#39;] must be an int or a list&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;rng_seed&#39;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;rng_seed&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;config[&#39;misc&#39;][&#39;rng_seed&#39;] must be an int or a list of len 5&quot;</span>
            <span class="n">rng_seed</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;rng_seed&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rng_seed</span> <span class="o">=</span> <span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;rng_seed&#39;</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">5</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using rng seeds from config: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rng_seed</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using default rng seeds: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">))</span>

    <span class="c1"># set brian2 default clock time step for simulation</span>
    <span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">clock_dt_ms</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>

    <span class="c1"># build differential equation of Leaky Integrate-and-Fire model from config</span>
    <span class="n">eqtn</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">Equations</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;ode&#39;</span><span class="p">])):</span>
        <span class="n">eqtn</span> <span class="o">+=</span> <span class="n">b2</span><span class="o">.</span><span class="n">Equations</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;ode&#39;</span><span class="p">][</span><span class="n">eq</span><span class="p">])</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Equation loaded&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b_verbose</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">eqtn</span><span class="p">)</span>

    <span class="c1"># misc parameters</span>
    <span class="n">refractory_period</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;refractory_period&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>
    <span class="n">population_id</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;population_id&#39;</span><span class="p">]</span>
    <span class="n">n_populations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population_id</span><span class="p">)</span>
    <span class="n">n_per_pop</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">]</span>
    <span class="n">n_neurons</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_per_pop</span><span class="p">)</span>
    <span class="n">n_synapses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;syn_pre_idx&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">sim_time_ms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sim_time_ms</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;sim_time&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;input_current&#39;</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">and</span> <span class="s1">&#39;power_ramp&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]:</span>
        <span class="n">b_power_ramp</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;power_ramp&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b_power_ramp</span> <span class="o">=</span> <span class="s1">&#39;[not in cfg]&#39;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;--- misc parameters ---</span><span class="se">\n</span><span class="s2">- Refractory period: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">refractory_period</span><span class="p">)</span> <span class="o">+</span>
             <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- N populations: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_populations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- N neurons per population: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_per_pop</span><span class="p">)</span> <span class="o">+</span>
             <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Simulation duration: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sim_time_ms</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- defaultclock.dt: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span>
             <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Power ramp: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b_power_ramp</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-----------------------&quot;</span><span class="p">)</span>

    <span class="c1"># # # # # # # # #</span>
    <span class="c1"># INPUT CURRENT #</span>
    <span class="c1"># # # # # # # # #</span>

    <span class="c1"># seed rng for input noise offset generation</span>
    <span class="n">b2</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># get a set of random numbers for continuous amplitude offsets in current generation</span>
    <span class="n">offset_noise</span> <span class="o">=</span> <span class="n">p_input</span><span class="o">.</span><span class="n">get_offset_noise</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">offset_noise</span><span class="p">)):</span>
        <span class="n">n_offset_values_per_pop</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">offset_noise</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offset_noise</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_offset_values_per_pop</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;~ &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_offset_values_per_pop</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; random numbers generated for&quot;</span> <span class="o">+</span>
                     <span class="s2">&quot; noise offset in input current generation&quot;</span><span class="p">)</span>

    <span class="c1"># re-seed rng for white noise generation</span>
    <span class="n">b2</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># get a set of random numbers for white noise to be added to current amplitudes</span>
    <span class="n">white_noise</span> <span class="o">=</span> <span class="n">p_input</span><span class="o">.</span><span class="n">get_white_noise</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">white_noise</span><span class="p">):</span>
        <span class="n">n_wnoise_values_per_pop</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">white_noise</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">white_noise</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_wnoise_values_per_pop</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;~ &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_wnoise_values_per_pop</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; random numbers generated for&quot;</span> <span class="o">+</span>
                     <span class="s2">&quot; white noise in input current generation&quot;</span><span class="p">)</span>

    <span class="c1"># re-seed rng for random initial voltage generation</span>
    <span class="n">b2</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="c1"># get a set of random numbers for initial voltage between resting potential and spiking threshold</span>
    <span class="n">initial_v_noise</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_populations</span>
    <span class="k">if</span> <span class="s1">&#39;rand_initial_v&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;rand_initial_v&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">]:</span>
                <span class="n">thresh_tmp</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_nrn&#39;</span><span class="p">][</span><span class="s1">&#39;v_thresh&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">]</span>
                <span class="n">rest_tmp</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_nrn&#39;</span><span class="p">][</span><span class="s1">&#39;El&#39;</span><span class="p">][</span><span class="n">pop</span><span class="p">]</span>
                <span class="n">initial_v_noise</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">thresh_tmp</span> <span class="o">-</span> <span class="n">rest_tmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">rest_tmp</span>

    <span class="c1"># if there&#39;s a non-zero parameter &quot;fI_amp_stepsize&quot; in &quot;input_current&quot;, generate a range of current amplitudes, each</span>
    <span class="c1"># feeding into a different neuron population (first neuron population will be cloned here as many times as needed)</span>
    <span class="c1"># NOTE: This overwrites values in config.</span>
    <span class="k">if</span> <span class="s1">&#39;fI_amp_stepsize&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;fI_amp_stepsize&#39;</span><span class="p">]:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;amp_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;when providing fI_amp_stepsize for &quot;</span> <span class="o">+</span> \
                                                                  <span class="s2">&quot;input_current, amp_start must have two entries &quot;</span> <span class="o">+</span> \
                                                                  <span class="s2">&quot;(lower and upper bound)&quot;</span>
        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;amp_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;amp_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">difference</span> <span class="o">=</span> <span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span>
        <span class="n">amp_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span>
                                <span class="nb">round</span><span class="p">(</span><span class="n">difference</span> <span class="o">/</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;fI_amp_stepsize&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">n_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">amp_steps</span><span class="p">)</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;t_start&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_steps</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;duration&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_steps</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;amp_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">amp_val</span><span class="p">]</span> <span class="k">for</span> <span class="n">amp_val</span> <span class="ow">in</span> <span class="n">amp_steps</span><span class="p">]</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;amp_end&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)]</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;offset_range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">][</span><span class="s1">&#39;offset_range&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_steps</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;~ generated &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; amplitude steps for input current: &quot;</span> <span class="o">+</span>
                 <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">amp_val</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="k">for</span> <span class="n">amp_val</span> <span class="ow">in</span> <span class="n">amp_steps</span><span class="p">]))</span>
        <span class="c1"># if number of populations is smaller than number of steps (could be 1), correct the number of populations</span>
        <span class="k">if</span> <span class="n">n_populations</span> <span class="o">&lt;</span> <span class="n">n_steps</span><span class="p">:</span>
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;population_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">population_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_steps</span>
            <span class="n">offset_noise</span> <span class="o">=</span> <span class="n">offset_noise</span> <span class="o">*</span> <span class="n">n_steps</span>
            <span class="n">white_noise</span> <span class="o">=</span> <span class="n">white_noise</span> <span class="o">*</span> <span class="n">n_steps</span>
            <span class="n">population_id</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;population_id&#39;</span><span class="p">]</span>
            <span class="n">n_populations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">population_id</span><span class="p">)</span>
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_per_pop</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_steps</span>
            <span class="n">n_per_pop</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">]</span>
            <span class="n">n_neurons</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_per_pop</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;~ number of populations extended to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_populations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_per_pop</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                     <span class="s2">&quot; neuron(s) per population each, for a total of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; neurons&quot;</span><span class="p">)</span>

    <span class="c1"># # # # # #</span>
    <span class="c1"># NEURONS #</span>
    <span class="c1"># # # # # #</span>

    <span class="c1"># create neurons (method must be changed for stochastic models)</span>
    <span class="n">t_neurongroup_start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;integration_method&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;integration_method&#39;</span><span class="p">]:</span>
        <span class="n">neurons</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">NeuronGroup</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">eqtn</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="s1">&#39;v &gt; v_thresh&#39;</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="s1">&#39;v = v_reset&#39;</span><span class="p">,</span>
                                 <span class="n">refractory</span><span class="o">=</span><span class="n">refractory_period</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;integration_method&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">neurons</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">NeuronGroup</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">eqtn</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="s1">&#39;v &gt; v_thresh&#39;</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="s1">&#39;v = v_reset&#39;</span><span class="p">,</span>
                                 <span class="n">refractory</span><span class="o">=</span><span class="n">refractory_period</span><span class="p">)</span>
    <span class="n">t_neurongroup_end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;NeuronGroup (n=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_neurons</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;) created in &quot;</span>
             <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_neurongroup_end</span> <span class="o">-</span> <span class="n">t_neurongroup_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span><span class="p">)</span>

    <span class="c1"># create subgroups (populations)</span>
    <span class="n">populations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
        <span class="n">n_so_far</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_per_pop</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">pop</span><span class="p">])</span>
        <span class="n">populations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neurons</span><span class="p">[</span><span class="n">n_so_far</span><span class="p">:</span><span class="n">n_so_far</span> <span class="o">+</span> <span class="n">n_per_pop</span><span class="p">[</span><span class="n">pop</span><span class="p">]])</span>

    <span class="c1"># # # # # # #</span>
    <span class="c1"># SYNAPSES  #</span>
    <span class="c1"># # # # # # #</span>

    <span class="c1"># re-seed rng for neuron connectivity</span>
    <span class="n">b2</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>

    <span class="c1"># build equation of synapse model from config</span>
    <span class="n">syn_eqtn_model</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">Equations</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;model&#39;</span><span class="p">])):</span>
        <span class="n">syn_eqtn_model</span> <span class="o">+=</span> <span class="n">b2</span><span class="o">.</span><span class="n">Equations</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;model&#39;</span><span class="p">][</span><span class="n">eq</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">b_verbose</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Synapse equation loaded: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">syn_eqtn_model</span><span class="p">))</span>

    <span class="c1"># load synapse on_pre equation(s), connection indices, probabilities and conditions from config</span>
    <span class="n">syn_eqtn_on_pre</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;on_pre&#39;</span><span class="p">]</span>
    <span class="n">syn_pre_idx</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;syn_pre_idx&#39;</span><span class="p">]</span>
    <span class="n">syn_post_idx</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;syn_post_idx&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="s1">&#39;connection_probability&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">]:</span>
        <span class="n">connection_probability</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;connection_probability&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connection_probability</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_synapses</span>
    <span class="k">if</span> <span class="s1">&#39;condition&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">]:</span>
        <span class="n">syn_condition</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">syn_condition</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_synapses</span>

    <span class="c1"># check for multiple on_pre equations and load indices per synapse from config</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">syn_eqtn_on_pre</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;on_pre_idx_syn&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;on_pre_idx_syn&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">n_synapses</span><span class="p">:</span>
            <span class="n">on_pre_idx_syn</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;on_pre_idx_syn&#39;</span><span class="p">]</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;- on_pre equations:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">syn_eqtn_on_pre</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; with indices per synapse: &quot;</span> <span class="o">+</span>
                     <span class="nb">str</span><span class="p">(</span><span class="n">on_pre_idx_syn</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Multiple equations in &#39;on_pre&#39; require list &#39;on_pre_idx_syn&#39; in &#39;synapse&#39;&quot;</span> <span class="o">+</span>
                      <span class="s2">&quot; with number of elements equal to number of synapses (i.e. len(syn_pre_idx))&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiple equations in &#39;on_pre&#39; require list &#39;on_pre_idx_syn&#39; in &#39;synapse&#39;&quot;</span> <span class="o">+</span>
                             <span class="s2">&quot; with number of elements equal to number of synapses (i.e. len(syn_pre_idx))&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">syn_eqtn_on_pre</span> <span class="o">=</span> <span class="p">[</span><span class="n">syn_eqtn_on_pre</span><span class="p">]</span>
        <span class="n">on_pre_idx_syn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_synapses</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;- on_pre equation:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">syn_eqtn_on_pre</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; for all &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_synapses</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; synapses&quot;</span><span class="p">)</span>

    <span class="c1"># check length of parameters</span>
    <span class="k">if</span> <span class="n">n_synapses</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">syn_pre_idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_post_idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">on_pre_idx_syn</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_condition</span><span class="p">)</span> <span class="ow">is</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">connection_probability</span><span class="p">)):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;syn_pre_idx, syn_post_idx, on_pre_idx_syn, syn_condition &amp; connection_probability must have &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;the same length (can contain empty elements)&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;syn_pre_idx, syn_post_idx, on_pre_idx_syn, syn_condition &amp; connection_probability must&quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;have the same length (can contain empty elements)&quot;</span><span class="p">)</span>
    <span class="c1"># create synapses</span>
    <span class="n">synapses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">t_synapses_start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapses</span><span class="p">):</span>
        <span class="n">synapses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">Synapses</span><span class="p">(</span><span class="n">populations</span><span class="p">[</span><span class="n">syn_pre_idx</span><span class="p">[</span><span class="n">syn</span><span class="p">]],</span> <span class="n">populations</span><span class="p">[</span><span class="n">syn_post_idx</span><span class="p">[</span><span class="n">syn</span><span class="p">]],</span>
                                    <span class="n">model</span><span class="o">=</span><span class="n">syn_eqtn_model</span><span class="p">,</span> <span class="n">on_pre</span><span class="o">=</span><span class="n">syn_eqtn_on_pre</span><span class="p">[</span><span class="n">on_pre_idx_syn</span><span class="p">[</span><span class="n">syn</span><span class="p">]]))</span>
        <span class="k">if</span> <span class="n">syn_condition</span><span class="p">[</span><span class="n">syn</span><span class="p">]:</span>
            <span class="n">synapses</span><span class="p">[</span><span class="n">syn</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">condition</span><span class="o">=</span><span class="n">syn_condition</span><span class="p">[</span><span class="n">syn</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="n">connection_probability</span><span class="p">[</span><span class="n">syn</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">synapses</span><span class="p">[</span><span class="n">syn</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">connection_probability</span><span class="p">[</span><span class="n">syn</span><span class="p">])</span>
    <span class="n">t_synapses_end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Synapses (n=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_synapses</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;) created in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_synapses_end</span> <span class="o">-</span> <span class="n">t_synapses_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
             <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span><span class="p">)</span>

    <span class="c1"># copy synaptic connection indices etc. for later saving</span>
    <span class="n">connectivity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapses</span><span class="p">):</span>
        <span class="n">connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapses</span><span class="p">[</span><span class="n">syn</span><span class="p">]</span><span class="o">.</span><span class="n">get_states</span><span class="p">([</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;N_incoming&#39;</span><span class="p">,</span> <span class="s1">&#39;N_outgoing&#39;</span><span class="p">]))</span>

    <span class="c1"># # # # # # # #</span>
    <span class="c1"># GENERATORS  #</span>
    <span class="c1"># # # # # # # #</span>

    <span class="c1"># re-seed rng for generator connectivity and poisson groups</span>
    <span class="n">b2</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rng_seed</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>

    <span class="c1"># create spike generators from passed input spiketimes to feed into model neurons</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_nrns_per_gen</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">connectivity_generator</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">input_spiketimes_ms</span><span class="p">:</span>
        <span class="n">t_spikegen_start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="n">n_generators</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_spiketimes_ms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_generators</span><span class="p">):</span>
            <span class="n">n_nrns_per_gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_spiketimes_ms</span><span class="p">[</span><span class="n">gen</span><span class="p">]))</span>
            <span class="n">n_spikes_per_gen_nrn</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">input_spiketimes_ms</span><span class="p">[</span><span class="n">gen</span><span class="p">][</span><span class="n">nrn</span><span class="p">])</span> <span class="k">for</span> <span class="n">nrn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_spiketimes_ms</span><span class="p">[</span><span class="n">gen</span><span class="p">]))]</span>
            <span class="n">generator_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_nrns_per_gen</span><span class="p">[</span><span class="n">gen</span><span class="p">])</span>
            <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">SpikeGeneratorGroup</span><span class="p">(</span><span class="n">n_nrns_per_gen</span><span class="p">[</span><span class="n">gen</span><span class="p">],</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">generator_indices</span><span class="p">,</span> <span class="n">n_spikes_per_gen_nrn</span><span class="p">),</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">input_spiketimes_ms</span><span class="p">[</span><span class="n">gen</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">))</span>

        <span class="c1"># check for generator synapse indices in config</span>
        <span class="k">if</span> <span class="s1">&#39;generator&#39;</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">and</span> <span class="s1">&#39;gen_pre_idx&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">][</span><span class="s1">&#39;gen_pre_idx&#39;</span><span class="p">]:</span>
            <span class="n">gen_pre_idx</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">][</span><span class="s1">&#39;gen_pre_idx&#39;</span><span class="p">]</span>
            <span class="n">gen_post_idx</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">][</span><span class="s1">&#39;gen_post_idx&#39;</span><span class="p">]</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;| generator synaptic indices loaded from config: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_pre_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_post_idx</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if none provided in config, connect one-to-one or all-to-all depending on number of generators/populations</span>
            <span class="k">if</span> <span class="n">n_generators</span> <span class="o">==</span> <span class="n">n_populations</span><span class="p">:</span>
                <span class="n">gen_pre_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_generators</span><span class="p">))</span>
                <span class="n">gen_post_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;| generator synaptic indices one-to-one: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_pre_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_post_idx</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">n_populations</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">gen_pre_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_generators</span><span class="p">))</span>
                <span class="n">gen_post_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_generators</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;| generator synaptic indices all-to-one: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_pre_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_post_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gen_pre_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_generators</span><span class="p">))</span> <span class="o">*</span> <span class="n">n_populations</span>
                <span class="n">tmp_post_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="p">[</span><span class="n">tmp_post_idx</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pop</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_generators</span><span class="p">)</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">)]</span>
                <span class="n">gen_post_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tmp_post_idx</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;| generator synaptic indices all-to-all: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_pre_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_post_idx</span><span class="p">))</span>
        <span class="n">n_gen_synapses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gen_pre_idx</span><span class="p">)</span>

        <span class="c1"># load generator on_pre equation(s), connection probabilities and conditions etc. from config</span>
        <span class="n">gen_eqtn_on_pre</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;synapse&#39;</span><span class="p">][</span><span class="s1">&#39;on_pre&#39;</span><span class="p">]</span>  <span class="c1"># note: gen_eqtn_on_pre is equal to syn_eqtn_on_pre</span>
        <span class="k">if</span> <span class="s1">&#39;connection_probability&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">]:</span>
            <span class="n">gen_connection_probability</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">][</span><span class="s1">&#39;connection_probability&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gen_connection_probability</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_gen_synapses</span>
        <span class="k">if</span> <span class="s1">&#39;condition&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">]:</span>
            <span class="n">gen_condition</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">][</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gen_condition</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_gen_synapses</span>

        <span class="c1"># check for multiple on_pre equations and load indices per generator from config</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gen_eqtn_on_pre</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;generator&#39;</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">and</span> <span class="s1">&#39;on_pre_idx_gen&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">]</span> \
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">][</span><span class="s1">&#39;on_pre_idx_gen&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="n">n_gen_synapses</span><span class="p">:</span>
                <span class="n">on_pre_idx_gen</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;generator&#39;</span><span class="p">][</span><span class="s1">&#39;on_pre_idx_gen&#39;</span><span class="p">]</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;- on_pre equations:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_eqtn_on_pre</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; with indices per generator: &quot;</span> <span class="o">+</span>
                         <span class="nb">str</span><span class="p">(</span><span class="n">on_pre_idx_gen</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Multiple equations in on_pre require list on_pre_idx_gen in generator, with number&quot;</span> <span class="o">+</span>
                          <span class="s2">&quot; of elements equal to number of generators (i.e. len(input_spiketimes_ms))&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiple equations in on_pre require list on_pre_idx_gen in generator, with number&quot;</span> <span class="o">+</span>
                                 <span class="s2">&quot; of elements equal to number of generators (i.e. len(input_spiketimes_ms))&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gen_eqtn_on_pre</span> <span class="o">=</span> <span class="p">[</span><span class="n">gen_eqtn_on_pre</span><span class="p">]</span>
            <span class="n">on_pre_idx_gen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_gen_synapses</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;- on_pre equation:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">gen_eqtn_on_pre</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; for all &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_generators</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; generators&quot;</span><span class="p">)</span>

        <span class="c1"># create synapses from generators onto model neurons</span>
        <span class="n">synapses_generator</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_gen_synapses</span><span class="p">):</span>
            <span class="n">synapses_generator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">Synapses</span><span class="p">(</span><span class="n">generators</span><span class="p">[</span><span class="n">gen_pre_idx</span><span class="p">[</span><span class="n">gen</span><span class="p">]],</span> <span class="n">populations</span><span class="p">[</span><span class="n">gen_post_idx</span><span class="p">[</span><span class="n">gen</span><span class="p">]],</span>
                                                  <span class="n">model</span><span class="o">=</span><span class="n">syn_eqtn_model</span><span class="p">,</span> <span class="n">on_pre</span><span class="o">=</span><span class="n">gen_eqtn_on_pre</span><span class="p">[</span><span class="n">on_pre_idx_gen</span><span class="p">[</span><span class="n">gen</span><span class="p">]]))</span>
            <span class="k">if</span> <span class="s1">&#39;generator&#39;</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">and</span> <span class="n">gen_condition</span><span class="p">[</span><span class="n">gen</span><span class="p">]:</span>
                <span class="n">synapses_generator</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">condition</span><span class="o">=</span><span class="n">gen_condition</span><span class="p">[</span><span class="n">gen</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="n">gen_connection_probability</span><span class="p">[</span><span class="n">gen</span><span class="p">])</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot; connection condition for generators loaded from config: &quot;</span> <span class="o">+</span> <span class="n">gen_condition</span><span class="p">[</span><span class="n">gen</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># default if no condition was supplied in config file</span>
                <span class="n">synapses_generator</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">gen_connection_probability</span><span class="p">[</span><span class="n">gen</span><span class="p">])</span>
        <span class="n">t_spikegen_end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Spikegenerators (n=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_generators</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;) and their synapses (n=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_gen_synapses</span><span class="p">)</span> <span class="o">+</span>
                 <span class="s2">&quot;) created in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_spikegen_end</span> <span class="o">-</span> <span class="n">t_spikegen_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span><span class="p">)</span>

        <span class="c1"># copy spikegenerator connection indices etc. for later saving</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_generators</span><span class="p">):</span>
            <span class="n">connectivity_generator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapses_generator</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span><span class="o">.</span><span class="n">get_states</span><span class="p">([</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;N_incoming&#39;</span><span class="p">,</span> <span class="s1">&#39;N_outgoing&#39;</span><span class="p">]))</span>

    <span class="c1"># # # # # # # # #</span>
    <span class="c1"># POISSON GROUP #</span>
    <span class="c1"># # # # # # # # #</span>

    <span class="c1"># generate poisson group, simulate once and record the spikes into a SpikeGenerator, to be used in all runs</span>
    <span class="k">if</span> <span class="s1">&#39;poisson_group&#39;</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">and</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">]:</span>
        <span class="c1"># get timed array containing the spike rate for the poisson group at each timestep in the simulation</span>
        <span class="n">timer_poisson_start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="n">poisson_rate</span> <span class="o">=</span> <span class="n">p_input</span><span class="o">.</span><span class="n">get_rates_for_poisson_group</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">log_name</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="o">=</span><span class="n">sim_time_ms</span><span class="p">)</span>

        <span class="c1"># generate poisson group and spike monitor</span>
        <span class="n">n_poisson_neurons</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons&#39;</span><span class="p">]</span>
        <span class="n">poisson</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">PoissonGroup</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">n_poisson_neurons</span><span class="p">,</span> <span class="n">rates</span><span class="o">=</span><span class="s1">&#39;poisson_rate(t)&#39;</span><span class="p">)</span>  <span class="c1"># string = name of timedarray</span>
        <span class="n">spikemon_poisson</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">poisson</span><span class="p">)</span>

        <span class="c1"># run simulation with poisson group once and record spikes</span>
        <span class="n">net_poisson</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">poisson</span><span class="p">,</span> <span class="n">spikemon_poisson</span><span class="p">)</span>
        <span class="n">net_poisson</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">sim_time_ms</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>

        <span class="c1"># construct spike generator with spikes created by the poisson group</span>
        <span class="n">generator_poisson</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">SpikeGeneratorGroup</span><span class="p">(</span><span class="n">n_poisson_neurons</span><span class="p">,</span> <span class="n">spikemon_poisson</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="n">spikemon_poisson</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># save recorded spikes and delete group and monitor (should not get added to subsequent networks)</span>
        <span class="n">spikes_poisson</span> <span class="o">=</span> <span class="n">spikemon_poisson</span><span class="o">.</span><span class="n">get_states</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">poisson</span>
        <span class="k">del</span> <span class="n">spikemon_poisson</span>

        <span class="c1"># connect the generator to the neuron populations given by config[&#39;poisson_group&#39;][&#39;syn_post_idx&#39;]</span>
        <span class="n">psn_syn_post_idx</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;syn_post_idx&#39;</span><span class="p">]</span>
        <span class="n">psn_on_pre_idx_syn</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;on_pre_idx_syn&#39;</span><span class="p">]</span>
        <span class="n">n_psn_synapses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psn_syn_post_idx</span><span class="p">)</span>
        <span class="n">synapses_poisson</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">psn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_psn_synapses</span><span class="p">):</span>
            <span class="n">synapses_poisson</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">Synapses</span><span class="p">(</span><span class="n">generator_poisson</span><span class="p">,</span> <span class="n">populations</span><span class="p">[</span><span class="n">psn_syn_post_idx</span><span class="p">[</span><span class="n">psn</span><span class="p">]],</span>
                                                <span class="n">model</span><span class="o">=</span><span class="n">syn_eqtn_model</span><span class="p">,</span> <span class="n">on_pre</span><span class="o">=</span><span class="n">syn_eqtn_on_pre</span><span class="p">[</span><span class="n">psn_on_pre_idx_syn</span><span class="p">[</span><span class="n">psn</span><span class="p">]]))</span>
            <span class="c1"># note: syn_condition for poisson group not implemented</span>
            <span class="n">synapses_poisson</span><span class="p">[</span><span class="n">psn</span><span class="p">]</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;poisson_group&#39;</span><span class="p">][</span><span class="s1">&#39;connection_probability&#39;</span><span class="p">][</span><span class="n">psn</span><span class="p">])</span>
        <span class="n">timer_poisson_end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Poisson Group (n=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_poisson_neurons</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;) spikes and synapses (n=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_psn_synapses</span><span class="p">)</span>
                 <span class="o">+</span> <span class="s2">&quot;) created in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">timer_poisson_end</span> <span class="o">-</span> <span class="n">timer_poisson_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spikes_poisson</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">generator_poisson</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># # # # # # # # # # # # #</span>
    <span class="c1"># MONITORS AND NETWORK  #</span>
    <span class="c1"># # # # # # # # # # # # #</span>

    <span class="c1"># set up state monitor (continuously record variables) and spike monitor (record spike times)</span>
    <span class="n">spike_cur_run</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span>
    <span class="n">state_cur_run</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">StateMonitor</span><span class="p">(</span><span class="n">neurons</span><span class="p">,</span> <span class="n">recorded_variables</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;o recorded variables: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">recorded_variables</span><span class="p">))</span>

    <span class="c1"># create network and add synapses, as they are  not automatically collected, because hidden in a container (list)</span>
    <span class="n">net</span> <span class="o">=</span> <span class="n">b2</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
    <span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">synapses</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">input_spiketimes_ms</span><span class="p">:</span>
        <span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">synapses_generator</span><span class="p">)</span>
        <span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">generators</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">generator_poisson</span><span class="p">:</span>
        <span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">generator_poisson</span><span class="p">)</span>
        <span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">synapses_poisson</span><span class="p">)</span>

    <span class="c1"># store network status (will be restored at the beginning of each run)</span>
    <span class="n">net</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>

    <span class="c1"># # # # # # # # # #</span>
    <span class="c1"># FREE PARAMETER  #</span>
    <span class="c1"># # # # # # # # # #</span>

    <span class="c1"># get name of free parameter, stepsize and dict containing it e.g. &quot;parameters_nrn&quot;; if the config file contains one</span>
    <span class="c1"># note: restricted to a single parameter atm!</span>
    <span class="n">free_parameter_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;free_parameter_stepsize&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">free_parameter_keys</span><span class="p">:</span>
        <span class="n">free_parameter_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">free_parameter_stepsize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">free_parameter_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">free_parameter_name</span> <span class="o">=</span> <span class="n">free_parameter_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">free_parameter_stepsize</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;free_parameter_stepsize&#39;</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">free_parameter_name</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_nrn&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_nrn&#39;</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">]</span> \
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_nrn&#39;</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">free_parameter_dict</span> <span class="o">=</span> <span class="s1">&#39;parameters_nrn&#39;</span>
        <span class="k">elif</span> <span class="n">free_parameter_name</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">]</span> \
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">free_parameter_dict</span> <span class="o">=</span> <span class="s1">&#39;parameters_syn&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;parameters_gen&#39;</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">and</span> <span class="n">free_parameter_name</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_gen&#39;</span><span class="p">]</span> \
                <span class="ow">and</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_gen&#39;</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">]</span> \
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;parameters_gen&#39;</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">free_parameter_dict</span> <span class="o">=</span> <span class="s1">&#39;parameters_gen&#39;</span>
        <span class="k">elif</span> <span class="n">free_parameter_name</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;input_current&#39;</span><span class="p">]:</span>
            <span class="n">free_parameter_dict</span> <span class="o">=</span> <span class="s1">&#39;input_current&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Free parameter name &#39;&quot;</span> <span class="o">+</span> <span class="n">free_parameter_name</span> <span class="o">+</span> <span class="s2">&quot;&#39; not found in dictionaries &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;&#39;parameters_nrn&#39;, &#39;parameters_syn&#39;, &#39;parameters_gen&#39; or &#39;input_current&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Free parameter name &#39;&quot;</span> <span class="o">+</span> <span class="n">free_parameter_name</span> <span class="o">+</span> <span class="s2">&quot;&#39; not found in dictionaries &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;&#39;parameters_nrn&#39;, &#39;parameters_syn&#39;, &#39;parameters_gen&#39; or &#39;input_current&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">free_parameter_name</span><span class="p">:</span>
        <span class="c1"># get all possible values for the free parameter (fp_values) within the range (lower_bound to upper_bound)</span>
        <span class="c1"># for the groups (populations or synapses) given in the config file.</span>
        <span class="n">fp_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># track for which group the free parameter changes (i.e. which input currents must be re-generated across runs)</span>
        <span class="n">b_fp_per_group</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">])):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">group</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">group</span><span class="p">]</span>
                <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">group</span><span class="p">]</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span>
                <span class="n">b_fp_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">fp_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">difference</span> <span class="o">/</span> <span class="n">free_parameter_stepsize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the free parameter contains three levels of nested lists (i.e. multiple values per group, like</span>
                <span class="c1"># some of the input_current parameters), loop through an additional level.</span>
                <span class="n">fp_values</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">group</span><span class="p">])):</span>
                    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">,</span> \
                        <span class="s2">&quot;too many levels in nested lists of free parameter &quot;</span> <span class="o">+</span> <span class="n">free_parameter_name</span> <span class="o">+</span> <span class="s2">&quot;? (max: [[[]]])&quot;</span>
                    <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">]</span>
                    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">]</span>
                    <span class="n">difference</span> <span class="o">=</span> <span class="n">upper_bound</span> <span class="o">-</span> <span class="n">lower_bound</span>
                    <span class="n">b_fp_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">difference</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span>
                                                        <span class="nb">round</span><span class="p">(</span><span class="n">difference</span> <span class="o">/</span> <span class="n">free_parameter_stepsize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># if the free parameter is varied for multiple populations, &#39;free_parameter_combination_type&#39; determines</span>
        <span class="c1"># whether all possible permutations should be simulated (&#39;product&#39;, e.g. [1,1], [1,2], [2,1], [2,2])</span>
        <span class="c1"># or whether values should be iterated in series (&#39;serial&#39;, e.g. [1,1], [2,2])</span>
        <span class="k">if</span> <span class="s1">&#39;free_parameter_combination_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;free_parameter_combination_type&#39;</span><span class="p">]</span> \
                <span class="ow">or</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;free_parameter_combination_type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;product&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">fp_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">,</span> <span class="s2">&quot;&#39;product&#39; combination not implemented for free parameters &quot;</span> <span class="o">+</span> \
                                                   <span class="s2">&quot;containing nested lists (e.g. input_current: t_start). Set &quot;</span> <span class="o">+</span> \
                                                   <span class="s2">&quot;&#39;free_parameter_combination_type&#39; to &#39;serial&#39; in config .json.&quot;</span>
            <span class="c1"># get a list of all combinations of these values</span>
            <span class="n">combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">fp_values</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;free_parameter_combination_type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;serial&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fp_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">fp_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fp_values</span><span class="p">))])</span>
                <span class="n">values_per_group</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># this will contain repetitions of the values that are not iterated</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fp_values</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">maxlen</span><span class="p">:</span>
                        <span class="n">values_per_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span>
                                                      <span class="p">(</span><span class="n">maxlen</span> <span class="o">-</span> <span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">values_per_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">]))</span>
                <span class="c1"># get a list of len(n_runs) with each sublist containing the parameter values for that run</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">values_per_group</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the free param contains three levels of nested lists, loop through an additional level (see above)</span>
                <span class="n">length_of_sublists</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">fp_values</span><span class="p">]</span>
                <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">length_of_sublists</span><span class="p">))</span>  <span class="c1"># maximum in flattened list</span>
                <span class="n">values_per_group</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># this will contain repetitions of the values that are not iterated</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fp_values</span><span class="p">)):</span>
                    <span class="n">values_per_group</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="k">for</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">])):</span>
                        <span class="k">if</span> <span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">maxlen</span><span class="p">:</span>
                            <span class="n">values_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span>
                                                                 <span class="p">(</span><span class="n">maxlen</span> <span class="o">-</span> <span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span>
                                                                 <span class="p">[</span><span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">values_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fp_values</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">]))</span>
                <span class="c1"># get a list of len(n_runs) with each sublist containing the parameter values for that run</span>
                <span class="n">combinations</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i_combination</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlen</span><span class="p">):</span>
                    <span class="n">combinations</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values_per_group</span><span class="p">)):</span>
                        <span class="n">combinations</span><span class="p">[</span><span class="n">i_combination</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="k">for</span> <span class="n">subval</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">])):</span>
                            <span class="n">combinations</span><span class="p">[</span><span class="n">i_combination</span><span class="p">][</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">][</span><span class="n">subval</span><span class="p">][</span><span class="n">i_combination</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: &#39;free_parameter_combination_type&#39; in .json should be either &#39;product&#39;, &#39;serial&#39; or empty&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;free_parameter_combination_type&#39; in .json should be either &#39;product&#39;, &#39;serial&#39; or empty&quot;</span><span class="p">)</span>
        <span class="c1"># number of simulation runs (one per combination of the free parameter)</span>
        <span class="n">n_runs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combinations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_runs</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># # # # # # # # # #</span>
    <span class="c1"># RUN SIMULATION  #</span>
    <span class="c1"># # # # # # # # # #</span>

    <span class="c1"># make a copy of the config dictionary to update the free parameter for each run in the following loop.</span>
    <span class="n">config_cur_run</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

    <span class="c1"># run simulation for each combination of the free parameter (if any)</span>
    <span class="n">states</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spikes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">info</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_runs</span><span class="p">):</span>
        <span class="c1"># get combination of values that is used for the free parameter in this run and get them into the copy</span>
        <span class="c1"># of the model config dictionary</span>
        <span class="k">if</span> <span class="n">free_parameter_name</span><span class="p">:</span>
            <span class="n">config_cur_run</span><span class="p">[</span><span class="n">free_parameter_dict</span><span class="p">][</span><span class="n">free_parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>

        <span class="c1"># restore network status</span>
        <span class="n">net</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>

        <span class="c1"># re-set spikes in spikegenerator. workaround for bug that got fixed in Brian2 v2.3, see here:</span>
        <span class="c1"># https://github.com/brian-team/brian2/issues/1084  todo: can be removed if using Brian2 version &gt;= 2.3</span>
        <span class="k">if</span> <span class="n">input_spiketimes_ms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_generators</span><span class="p">):</span>
                <span class="n">generators</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span><span class="o">.</span><span class="n">set_spikes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">generator_indices</span><span class="p">,</span> <span class="n">n_spikes_per_gen_nrn</span><span class="p">),</span>
                                           <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">input_spiketimes_ms</span><span class="p">[</span><span class="n">gen</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>

        <span class="c1"># generate input currents</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">I_input</span><span class="p">,</span> <span class="n">log_msg_curr</span> <span class="o">=</span> <span class="n">p_input</span><span class="o">.</span><span class="n">setup_currents</span><span class="p">(</span><span class="n">config_cur_run</span><span class="p">,</span> <span class="n">offset_noise</span><span class="p">,</span> <span class="n">white_noise</span><span class="p">,</span> <span class="n">log_name</span><span class="p">,</span>
                                                           <span class="n">sim_time_ms</span><span class="o">=</span><span class="n">sim_time_ms</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">log_msg_curr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">free_parameter_dict</span> <span class="o">==</span> <span class="s1">&#39;input_current&#39;</span><span class="p">:</span>
            <span class="n">I_input</span><span class="p">,</span> <span class="n">log_msg_curr</span> <span class="o">=</span> <span class="n">p_input</span><span class="o">.</span><span class="n">setup_currents</span><span class="p">(</span><span class="n">config_cur_run</span><span class="p">,</span> <span class="n">offset_noise</span><span class="p">,</span> <span class="n">white_noise</span><span class="p">,</span> <span class="n">log_name</span><span class="p">,</span>
                                                           <span class="n">I_input_prev</span><span class="o">=</span><span class="n">I_input</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="o">=</span><span class="n">sim_time_ms</span><span class="p">,</span>
                                                           <span class="n">b_gen_curr_per_pop</span><span class="o">=</span><span class="n">b_fp_per_group</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">log_msg_curr</span><span class="p">)</span>

        <span class="c1"># get parameters and initial states and their corresponding units from config_cur_run</span>
        <span class="c1"># El: Resting potential</span>
        <span class="c1"># Rm: Membrane resistance</span>
        <span class="c1"># Ie: Input current</span>
        <span class="c1"># Is: Synaptic current</span>
        <span class="c1"># taum: membrane time constant</span>
        <span class="c1"># v_thresh: threshold potential for spike generation</span>
        <span class="c1"># v_reset: reset potential after spike</span>
        <span class="c1"># tau1, tau2: synaptic time constants</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_nrn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]):</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;b2.&#39;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                              <span class="s2">&quot;&#39; for nrn parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                                     <span class="s2">&quot;&#39; for nrn parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* no unit found in &quot;</span> <span class="o">+</span> <span class="n">model_name</span> <span class="o">+</span> <span class="s2">&quot; for nrn parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot; =&gt; assigning 1&quot;</span><span class="p">)</span>
            <span class="c1"># if one value is given but multiple populations, repeat that value for all populations</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_populations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* single value &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; given for parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span>
                         <span class="s2">&quot; =&gt; using for all populations&quot;</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">n_populations</span>
                <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_nrn&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">populations</span><span class="p">[</span><span class="n">pop</span><span class="p">],</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">b_verbose</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;- parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; for population &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; set to &lt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">pop</span><span class="p">])</span> <span class="o">+</span>
                             <span class="s2">&quot;&gt; with unit &quot;</span> <span class="o">+</span> <span class="n">unit</span><span class="p">)</span>
            <span class="c1"># randomize initial conditions</span>
            <span class="k">if</span> <span class="n">param</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span> <span class="ow">and</span> <span class="s1">&#39;rand_initial_v&#39;</span> <span class="ow">in</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_populations</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">initial_v_noise</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">nrn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">populations</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">)):</span>
                            <span class="n">populations</span><span class="p">[</span><span class="n">pop</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">nrn</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_v_noise</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">nrn</span><span class="p">]</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># get synaptic parameters and their respective units from config_cur_run</span>
        <span class="c1"># w: Synaptic weight</span>
        <span class="c1"># delay: Synaptic delay</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]):</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;b2.&#39;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                              <span class="s2">&quot;&#39; for syn parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                                     <span class="s2">&quot;&#39; for syn parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* no unit found in &quot;</span> <span class="o">+</span> <span class="n">model_name</span> <span class="o">+</span> <span class="s2">&quot; for syn parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot; =&gt; assigning 1&quot;</span><span class="p">)</span>
            <span class="c1"># if one value is given but multiple populations, repeat that value for all populations</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_synapses</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* single value &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; given for synaptic parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span>
                         <span class="s2">&quot; =&gt; using for all synapses&quot;</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">n_synapses</span>
                <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synapses</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">synapses</span><span class="p">[</span><span class="n">syn</span><span class="p">],</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="n">syn</span><span class="p">]</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>

        <span class="c1"># get synaptic parameters for spike generator</span>
        <span class="k">if</span> <span class="n">input_spiketimes_ms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_gen&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]):</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;b2.&#39;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                                  <span class="s2">&quot;&#39; for syn parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                                         <span class="s2">&quot;&#39; for gen parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* no unit found in &quot;</span> <span class="o">+</span> <span class="n">model_name</span> <span class="o">+</span> <span class="s2">&quot; for generator parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span>
                             <span class="s2">&quot; =&gt; assigning 1&quot;</span><span class="p">)</span>
                <span class="c1"># if one value is given but multiple populations, repeat that value for all populations</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_gen_synapses</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* single value &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; given for generator parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span>
                             <span class="s2">&quot; =&gt; using for all generator connections&quot;</span><span class="p">)</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">n_gen_synapses</span>
                    <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_gen&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_gen_synapses</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">synapses_generator</span><span class="p">[</span><span class="n">gen</span><span class="p">],</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>

        <span class="c1"># get synaptic parameters for poisson group</span>
        <span class="k">if</span> <span class="n">generator_poisson</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_psn&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b2</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]):</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;b2.&#39;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;ERROR: Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                                  <span class="s2">&quot;&#39; for psn parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized unit &#39;&quot;</span> <span class="o">+</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameter_units&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">+</span>
                                         <span class="s2">&quot;&#39; for psn parameter &#39;&quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span> <span class="s2">&quot;&#39; in &quot;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* no unit found in &quot;</span> <span class="o">+</span> <span class="n">model_name</span> <span class="o">+</span> <span class="s2">&quot; for poisson group parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span>
                             <span class="s2">&quot; =&gt; assigning 1&quot;</span><span class="p">)</span>
                <span class="c1"># if one value is given but multiple populations, repeat that value for all populations</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_psn_synapses</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;* single value &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; given for poisson group parameter &quot;</span> <span class="o">+</span> <span class="n">param</span> <span class="o">+</span>
                             <span class="s2">&quot; =&gt; using for all poisson group connections&quot;</span><span class="p">)</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">n_psn_synapses</span>
                    <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_psn&#39;</span><span class="p">][</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">psn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_psn_synapses</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">synapses_poisson</span><span class="p">[</span><span class="n">psn</span><span class="p">],</span> <span class="n">param</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="n">psn</span><span class="p">]</span> <span class="o">*</span> <span class="nb">eval</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>

        <span class="c1"># run and time simulation</span>
        <span class="n">t_sim_start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">recording_start_ms</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">recording_start_ms</span> <span class="o">&lt;</span> <span class="n">sim_time_ms</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;o starting recording spikes and states at &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">recording_start_ms</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ms into the simulation&quot;</span><span class="p">)</span>
            <span class="n">state_cur_run</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">spike_cur_run</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">recording_start_ms</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
            <span class="n">state_cur_run</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">spike_cur_run</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">net</span><span class="o">.</span><span class="n">run</span><span class="p">((</span><span class="n">sim_time_ms</span> <span class="o">-</span> <span class="n">recording_start_ms</span><span class="p">)</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">sim_time_ms</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span><span class="p">)</span>
        <span class="c1"># net.run(sim_time_ms * b2.ms, profile=True)</span>
        <span class="c1"># print(b2.profiling_summary(net, show=10))</span>
        <span class="n">run_time</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_sim_start</span>

        <span class="c1"># output run time (and values for free parameter, if any)</span>
        <span class="k">if</span> <span class="n">free_parameter_name</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; finished in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">run_time</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; seconds. Values for free param &#39;&quot;</span> <span class="o">+</span>
                     <span class="n">free_parameter_name</span> <span class="o">+</span> <span class="s2">&quot;&#39;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">combinations</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; finished in &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">run_time</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; seconds.&quot;</span><span class="p">)</span>

        <span class="c1"># check which parameters are available for info dict</span>
        <span class="n">syn_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s1">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">]:</span>
            <span class="n">syn_weights</span> <span class="o">=</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">][</span><span class="s1">&#39;w&#39;</span><span class="p">]</span>

        <span class="c1"># create dictionary containing additional information about simulation</span>
        <span class="k">if</span> <span class="n">free_parameter_name</span><span class="p">:</span>
            <span class="n">free_parameter_values</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_parameter_values</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="n">model_name</span><span class="p">,</span>
                     <span class="s1">&#39;run_id&#39;</span><span class="p">:</span> <span class="n">run_id</span><span class="p">,</span>
                     <span class="s1">&#39;run_date&#39;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span>
                     <span class="s1">&#39;run_time&#39;</span><span class="p">:</span> <span class="n">run_time</span><span class="p">,</span>
                     <span class="s1">&#39;n_populations&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">populations</span><span class="p">),</span>
                     <span class="s1">&#39;population_ids&#39;</span><span class="p">:</span> <span class="n">population_id</span><span class="p">,</span>
                     <span class="s1">&#39;population_sizes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">pop</span><span class="o">.</span><span class="n">N</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">populations</span><span class="p">],</span>
                     <span class="s1">&#39;generator_sizes&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">gen</span><span class="o">.</span><span class="n">N</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">],</span>
                     <span class="s1">&#39;sim_time&#39;</span><span class="p">:</span> <span class="n">sim_time_ms</span><span class="p">,</span>
                     <span class="s1">&#39;dt&#39;</span><span class="p">:</span> <span class="n">b2</span><span class="o">.</span><span class="n">defaultclock</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
                     <span class="s1">&#39;v_thresh&#39;</span><span class="p">:</span> <span class="n">neurons</span><span class="o">.</span><span class="n">v_thresh</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span><span class="p">,</span>
                     <span class="s1">&#39;syn_pre_idx&#39;</span><span class="p">:</span> <span class="n">syn_pre_idx</span><span class="p">,</span>
                     <span class="s1">&#39;syn_post_idx&#39;</span><span class="p">:</span> <span class="n">syn_post_idx</span><span class="p">,</span>
                     <span class="s1">&#39;syn_weight&#39;</span><span class="p">:</span> <span class="n">syn_weights</span><span class="p">,</span>
                     <span class="s1">&#39;syn_delay&#39;</span><span class="p">:</span> <span class="n">config_cur_run</span><span class="p">[</span><span class="s1">&#39;parameters_syn&#39;</span><span class="p">][</span><span class="s1">&#39;delay&#39;</span><span class="p">],</span>
                     <span class="s1">&#39;free_parameter_name&#39;</span><span class="p">:</span> <span class="n">free_parameter_name</span><span class="p">,</span>
                     <span class="s1">&#39;free_parameter_dict&#39;</span><span class="p">:</span> <span class="n">free_parameter_dict</span><span class="p">,</span>
                     <span class="s1">&#39;free_parameter_values&#39;</span><span class="p">:</span> <span class="n">free_parameter_values</span><span class="p">,</span>
                     <span class="s1">&#39;connection_probability&#39;</span><span class="p">:</span> <span class="n">connection_probability</span><span class="p">})</span>

        <span class="c1"># save states and spikes into lists</span>
        <span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state_cur_run</span><span class="o">.</span><span class="n">get_states</span><span class="p">())</span>
        <span class="n">spikes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spike_cur_run</span><span class="o">.</span><span class="n">get_states</span><span class="p">())</span>

        <span class="c1"># end for r in range(n_runs)</span>

    <span class="c1"># build standalone code</span>
    <span class="k">if</span> <span class="n">STANDALONE_CODE_GEN</span><span class="p">:</span>
        <span class="n">b2</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="nb">compile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># save results</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">b_always_save_output</span><span class="p">:</span>
        <span class="n">conditions_not_met</span> <span class="o">=</span> <span class="n">is_not_worth_saving</span><span class="p">(</span><span class="n">spikes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">config</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conditions_not_met</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">b_always_save_output</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">conditions_not_met</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">p_io</span><span class="o">.</span><span class="n">save_monitors</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">spikes_poisson</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">connectivity_generator</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span>
                                 <span class="n">filename_out</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># copy config file contents to log file (if there is one)</span>
    <span class="n">file_hndlr</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">handlers</span><span class="p">))</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">file_hndlr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">filename_cfg</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_hndlr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">baseFilename</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_log</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_cfg</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_cfg</span><span class="p">:</span>
                <span class="n">file_log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">======= &quot;</span> <span class="o">+</span> <span class="n">filename_cfg</span> <span class="o">+</span> <span class="s2">&quot; =======</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_cfg</span><span class="p">:</span>
                    <span class="n">file_log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_hndlr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">baseFilename</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_log</span><span class="p">:</span>
                <span class="n">file_log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">======= preloaded config =======</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">file_log</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">file_log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">======= end =======</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filename_out</span><span class="p">,</span> <span class="n">conditions_not_met</span></div>


<div class="viewcode-block" id="is_not_worth_saving"><a class="viewcode-back" href="../lif.html#lif.is_not_worth_saving">[docs]</a><span class="k">def</span> <span class="nf">is_not_worth_saving</span><span class="p">(</span><span class="n">spikemon</span><span class="p">,</span> <span class="n">statemon</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check certain conditions for whether to save the ouput of the current simulation, based on some of its results.</span>

<span class="sd">    :param spikemon: dict containing SpikeMonitor data from b2...get_states()</span>
<span class="sd">    :type spikemon: dict</span>
<span class="sd">    :param statemon: dict containing StateMonitor data from b2...get_states()</span>
<span class="sd">    :type statemon: dict</span>
<span class="sd">    :param info: dictionary containing additional information about simulation (as created by run_simulation())</span>
<span class="sd">    :type info: dict</span>
<span class="sd">    :param config: dictionary of model parameters, as loaded from .json configuration file</span>
<span class="sd">    :type config: dict</span>
<span class="sd">    :return:  conditions_not_met: list of indices of conditions not met (if any)</span>
<span class="sd">    :rtype:   conditions_not_met: list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get neuron of interest from config</span>
    <span class="n">nrn_oi_abs</span> <span class="o">=</span> <span class="n">p_util</span><span class="o">.</span><span class="n">get_abs_from_rel_nrn_idx</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;plot&#39;</span><span class="p">][</span><span class="s1">&#39;idx_nrn_oi_relative&#39;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;plot&#39;</span><span class="p">][</span><span class="s1">&#39;idx_pop_oi&#39;</span><span class="p">],</span>
                                                 <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">])</span>
    <span class="c1"># assure that neuron of interest spikes at all, doesn&#39;t spike until a certain time, has a maximum number of spikes</span>
    <span class="c1"># and doesn&#39;t cross a minimum membrane potential</span>
    <span class="n">min_t_first_spike_ms</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span>
    <span class="n">max_n_spikes</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">min_voltage</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
    <span class="n">b_spike_from_nrn_oi</span> <span class="o">=</span> <span class="n">spikemon</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">nrn_oi_abs</span>
    <span class="n">n_spikes_nrn_oi</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b_spike_from_nrn_oi</span><span class="p">)</span>
    <span class="n">spiketimes_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_util</span><span class="o">.</span><span class="n">get_spiketimes_from_monitor</span><span class="p">(</span><span class="n">spikemon</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">statemon</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">ms</span> <span class="o">&gt;=</span> <span class="n">t2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_int_spikes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">spiketimes_int</span> <span class="o">&gt;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">spiketimes_int</span> <span class="o">&lt;</span> <span class="n">t2</span><span class="p">))</span> <span class="o">/</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;misc&#39;</span><span class="p">][</span><span class="s1">&#39;n_neurons_per_pop&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">spikerate_int</span> <span class="o">=</span> <span class="n">n_int_spikes</span> <span class="o">/</span> <span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="n">baseline_pm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">statemon</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">,</span> <span class="n">nrn_oi_abs</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span><span class="p">)</span>
    <span class="n">baseline_std_pm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">statemon</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">][</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">,</span> <span class="n">nrn_oi_abs</span><span class="p">]</span> <span class="o">/</span> <span class="n">b2</span><span class="o">.</span><span class="n">mV</span><span class="p">)</span>
    <span class="c1"># check for conditions not met and add their ids to the returned list</span>
    <span class="n">conditions_not_met</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># if not any(b_spike_from_nrn_oi):</span>
    <span class="c1">#    conditions_not_met += [1]  # nrn_oi_spikes</span>
    <span class="c1"># if any(statemon[&#39;v&#39;][:, nrn_oi_abs] / b2.mV &lt; min_voltage):</span>
    <span class="c1">#     conditions_not_met += [2]  # nrn_oi_min_v</span>
    <span class="c1"># if any(b_spike_from_nrn_oi) and not any(spikemon[&#39;t&#39;][np.where(b_spike_from_nrn_oi)[0]] &gt; min_t_first_spike_ms):</span>
    <span class="c1">#     conditions_not_met += [3]  # must_spike_late</span>
    <span class="c1"># if n_spikes_nrn_oi &gt; max_n_spikes:</span>
    <span class="c1">#     conditions_not_met += [4]  # nrn_oi_few_spikes</span>
    <span class="c1"># if baseline_pm &gt; -45:</span>
    <span class="c1">#     conditions_not_met += [5]  # baseline_low</span>
    <span class="c1"># if baseline_pm &lt; -65:</span>
    <span class="c1">#     conditions_not_met += [6]  # baseline_high</span>
    <span class="c1"># if spikerate_int &gt; 100:</span>
    <span class="c1">#     conditions_not_met += [7]  # IN_rate_low</span>
    <span class="c1"># if spikerate_int &lt; 5:</span>
    <span class="c1">#     conditions_not_met += [8]  # IN_rate_high</span>
    <span class="c1"># if baseline_std_pm &gt; 1.5:</span>
    <span class="c1">#     conditions_not_met += [9]  # baseline_stdev_high</span>
    <span class="k">return</span> <span class="n">conditions_not_met</span></div>


<div class="viewcode-block" id="unwrap_arguments"><a class="viewcode-back" href="../lif.html#lif.unwrap_arguments">[docs]</a><span class="k">def</span> <span class="nf">unwrap_arguments</span><span class="p">(</span><span class="n">argument_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unwraps a list of arguments and calls run_simulation with the individual arguments contained in the list</span>

<span class="sd">    :param argument_list: list of arguments to be passed to function</span>
<span class="sd">    :type argument_list: list</span>
<span class="sd">    :return: returns a list of the return value(s) of run_simulation (if any), or an exception if one got raised</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument_list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="s2">&quot;argument_list must be a list or tuple&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">rvalue1</span><span class="p">,</span> <span class="n">rvalue2</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="o">*</span><span class="n">argument_list</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">rvalue1</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">rvalue2</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">rvalue1</span><span class="p">,</span> <span class="n">rvalue2</span><span class="p">]</span></div>


<div class="viewcode-block" id="run_multiprocess"><a class="viewcode-back" href="../lif.html#lif.run_multiprocess">[docs]</a><span class="k">def</span> <span class="nf">run_multiprocess</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">configs_list</span><span class="p">,</span> <span class="n">filename_out_list</span><span class="p">,</span> <span class="n">log_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">run_id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim_time_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">clock_dt_ms</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">input_spiketimes_ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">recorded_variables</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">recording_start_ms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b_save_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run multiple simulations in parallel. Takes a list of configs and ouput filenames and runs simulations based on</span>
<span class="sd">    each config in parallel using multiprocessing.</span>

<span class="sd">    :param model_name: filename of parameter config file (ending .json can be omitted from string). config will not be</span>
<span class="sd">        loaded from this file, but from the configs in configs_list below.</span>
<span class="sd">    :type model_name: str</span>
<span class="sd">    :param configs_list: list of config dictionaries, one dict per simulation to be run in parallel</span>
<span class="sd">    :type configs_list: list</span>
<span class="sd">    :param filename_out_list: list of filenames for the output .pkl files.</span>
<span class="sd">    :type filename_out_list: list</span>
<span class="sd">    :param log_name: see run_simulation() in this module</span>
<span class="sd">    :type log_name: str or None</span>
<span class="sd">    :param run_id: see run_simulation() in this module</span>
<span class="sd">    :type run_id: int</span>
<span class="sd">    :param sim_time_ms: see run_simulation() in this module</span>
<span class="sd">    :type sim_time_ms: int or None</span>
<span class="sd">    :param clock_dt_ms: see run_simulation() in this module</span>
<span class="sd">    :type clock_dt_ms: float</span>
<span class="sd">    :param input_spiketimes_ms: see run_simulation() in this module</span>
<span class="sd">    :type input_spiketimes_ms: [[[float]]] or None</span>
<span class="sd">    :param b_verbose: see run_simulation() in this module</span>
<span class="sd">    :type b_verbose: bool or int</span>
<span class="sd">    :param batch_size: number of processes (simulations) to run in a batch. None: no batching</span>
<span class="sd">    :type batch_size: int or None</span>
<span class="sd">    :param recorded_variables: (tuple of) name(s) of the variable(s) to be recorded in StateMonitor and saved to .pkl</span>
<span class="sd">    :type recorded_variables: str or tuple</span>
<span class="sd">    :param recording_start_ms: [default=0] start recording spikes and states at this timepoint into the simulation</span>
<span class="sd">    :type recording_start_ms: float or int</span>
<span class="sd">    :param b_save_all: if True, saving_conditions will be ignored, i.e. an ouput .pkl file saved for every sim run.</span>
<span class="sd">    :type b_save_all: bool or int</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check inputs</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configs_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">configs_list</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">configs_list</span><span class="p">))]),</span> \
           <span class="s2">&quot;run_multiprocess(): argument &#39;configs_list&#39; must be a list of configuration dictionaries&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename_out_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">filename_out_list</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filename_out_list</span><span class="p">))]),</span> \
           <span class="s2">&quot;run_multiprocess(): argument &#39;configs_list&#39; must be a list of configuration dictionaries&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">configs_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">filename_out_list</span><span class="p">),</span> <span class="s2">&quot;configs_list and filename_out_list must be of same length&quot;</span>

    <span class="c1"># get logger</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">log_name</span><span class="p">)</span>

    <span class="c1"># Tell brian2 to not delete delete source files after compiling. The Cython source files can take a significant</span>
    <span class="c1"># amount of disk space, and are not used anymore when the compiled library file exists. However, parallel</span>
    <span class="c1"># processing, deleting source files while another process looks for them can be problematic,</span>
    <span class="c1"># see https://github.com/brian-team/brian2/issues/1081</span>
    <span class="c1"># b2.prefs.codegen.runtime.cython.delete_source_files = False</span>
    <span class="c1"># =&gt; didn&#39;t work, instead set cache size to 0 in file brian_preferences</span>

    <span class="c1"># to avoid memory issues, create a new pool every 100 simulations</span>
    <span class="n">n_simulations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">configs_list</span><span class="p">)</span>
    <span class="n">n_sims_run</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_sims_saved</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">batch_size</span><span class="p">:</span>
        <span class="n">n_batches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_simulations</span> <span class="o">/</span> <span class="n">batch_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;_ starting run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">run_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; multiprocess (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; sims) with batch size &quot;</span> <span class="o">+</span>
                 <span class="nb">str</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; ...&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_batches</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;_ starting run &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">run_id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; multiprocess (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_simulations</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; sims), no batches ...&quot;</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Simulations completed (/exception):&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i_batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_batches</span><span class="p">):</span>
        <span class="c1"># create context with start method &quot;spawn&quot; - see https://pythonspeed.com/articles/python-multiprocessing/</span>
        <span class="c1"># and https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods</span>
        <span class="c1"># NOTE: The &#39;spawn&#39; and &#39;forkserver&#39; start methods cannot currently be used with “frozen” executables (i.e.,</span>
        <span class="c1"># binaries produced by packages like PyInstaller and cx_Freeze) on Unix. The &#39;fork&#39; start method does work.</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;forkserver&#39;</span><span class="p">)</span>
        <span class="c1"># create multiprocessing pool</span>
        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">batch_size</span><span class="p">:</span>
                <span class="n">sim_slice_cur_batch</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">*</span> <span class="n">i_batch</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="n">i_batch</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sim_slice_cur_batch</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># run simulations</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">unwrap_arguments</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">model_name</span><span class="p">),</span>
                                                                                 <span class="n">configs_list</span><span class="p">[</span><span class="n">sim_slice_cur_batch</span><span class="p">],</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">run_id</span><span class="p">),</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">sim_time_ms</span><span class="p">),</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">clock_dt_ms</span><span class="p">),</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">input_spiketimes_ms</span><span class="p">),</span>
                                                                                 <span class="n">filename_out_list</span><span class="p">[</span><span class="n">sim_slice_cur_batch</span><span class="p">],</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">recorded_variables</span><span class="p">),</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">recording_start_ms</span><span class="p">),</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">b_save_all</span><span class="p">),</span>
                                                                                 <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">b_verbose</span><span class="p">))))):</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.pkl&#39;</span><span class="p">):</span>
                    <span class="c1"># output id (end of filename) of completed sim to log file only (level debug does not go to console)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">])))</span>
                        <span class="n">n_sims_saved</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;exception: &#39;</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># start timer once and calculte estimated time left every 100 sims</span>
                <span class="k">if</span> <span class="n">n_sims_run</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
                    <span class="n">last_timer</span> <span class="o">=</span> <span class="n">start</span>
                    <span class="n">eta</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">n_sims_run</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">n_sims_run</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">t_elapsed</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">last_timer</span>
                    <span class="n">last_timer</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
                    <span class="n">eta</span> <span class="o">=</span> <span class="n">t_elapsed</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">configs_list</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_sims_run</span><span class="p">)</span>
                <span class="c1"># print to console number of sims done, percentage done and estimated time left</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">34</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{0: &gt;6}</span><span class="s1"> </span><span class="si">{1: &gt;6}</span><span class="s1">% </span><span class="si">{2: &gt;6}</span><span class="s1">min </span><span class="si">{3: &gt;6}</span><span class="s1">out&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n_sims_run</span><span class="p">),</span>
                                                                                  <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">n_sims_run</span> <span class="o">/</span>
                                                                                        <span class="nb">len</span><span class="p">(</span><span class="n">configs_list</span><span class="p">),</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span>
                                                                                  <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">eta</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)),</span>
                                                                                  <span class="nb">str</span><span class="p">(</span><span class="n">n_sims_saved</span><span class="p">)),</span>
                      <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># alternatively use starmap (doesn&#39;t return iteratively, so no progress bar possible)</span>
                <span class="c1"># pool.starmap(run_simulation, zip(itertools.repeat(model_name), ...))</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\b\b\b\b\b\b\b\b\b\b\b\b\b\b</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">batch_size</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;batch </span><span class="si">{0: &gt;3}</span><span class="s1"> done. runtime: </span><span class="si">{1: &gt;3}</span><span class="s1">s. estimated time left: </span><span class="si">{2}</span><span class="s1"> min&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i_batch</span><span class="p">),</span>
                    <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">duration</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">duration</span> <span class="o">/</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_simulations</span> <span class="o">-</span> <span class="n">n_sims_run</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Philipp Norton.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>